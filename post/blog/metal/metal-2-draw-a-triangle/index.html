<!doctype html><html lang=zh itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Metal - 2 画一个三角形 - Kim's Blog</title><meta name=description content="本篇文章的目标是使用 Metal 渲染一个 渐变色三角形。
可以了解到 Metal 和 Render 相关 Api 的基本使用。
具体代码可以访问 仓库 的 1. 三角形。"><meta name=author content="Kim"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Kim\x27s Blog","url":"https:\/\/www.uiimage.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/www.uiimage.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/www.uiimage.com\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/www.uiimage.com\/post\/blog\/metal\/metal-2-draw-a-triangle\/","name":"Metal 2 画一个三角形"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Kim"},"headline":"Metal - 2 画一个三角形","description":"本篇文章的目标是使用 Metal 渲染一个 渐变色三角形。\n可以了解到 Metal 和 Render 相关 Api 的基本使用。\n具体代码可以访问 仓库 的 1. 三角形。\n","inLanguage":"zh","wordCount":938,"datePublished":"2020-05-29T23:00:00","dateModified":"2020-05-29T23:00:00","image":"https:\/\/www.uiimage.com\/img\/avatar.JPG","keywords":["iOS, Metal, 音视频"],"mainEntityOfPage":"https:\/\/www.uiimage.com\/post\/blog\/metal\/metal-2-draw-a-triangle\/","publisher":{"@type":"Organization","name":"https:\/\/www.uiimage.com\/","logo":{"@type":"ImageObject","url":"https:\/\/www.uiimage.com\/img\/avatar.JPG","height":60,"width":60}}}</script><meta property="og:title" content="Metal - 2 画一个三角形"><meta property="og:description" content="本篇文章的目标是使用 Metal 渲染一个 渐变色三角形。
可以了解到 Metal 和 Render 相关 Api 的基本使用。
具体代码可以访问 仓库 的 1. 三角形。"><meta property="og:image" content="https://www.uiimage.com/img/avatar.JPG"><meta property="og:url" content="https://www.uiimage.com/post/blog/metal/metal-2-draw-a-triangle/"><meta property="og:type" content="website"><meta property="og:site_name" content="Kim's Blog"><meta name=twitter:title content="Metal - 2 画一个三角形"><meta name=twitter:description content="本篇文章的目标是使用 Metal 渲染一个 渐变色三角形。
可以了解到 Metal 和 Render 相关 Api 的基本使用。
具体代码可以访问 仓库 的 1. 三角形。"><meta name=twitter:image content="https://www.uiimage.com/img/avatar.JPG"><meta name=twitter:card content="summary"><link href=https://www.uiimage.com/img/avatar.JPG rel=icon type=image/x-icon><meta name=generator content="Hugo 0.69.2"><link rel=alternate href=https://www.uiimage.com/index.xml type=application/rss+xml title="Kim's Blog"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://www.uiimage.com/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://www.uiimage.com/css/syntax.css><link rel=stylesheet href=https://www.uiimage.com/css/codeblock.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css integrity=sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css integrity=sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>切换导航</span>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button>
<a class=navbar-brand href=https://www.uiimage.com/>Kim's Blog</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Home href=/>Home</a></li><li><a title=Tags href=/tags>Tags</a></li><li><a title=About href=/page/about/>About</a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Kim's Blog" href=https://www.uiimage.com/><img class=avatar-img src=https://www.uiimage.com/img/avatar.JPG alt="Kim's Blog"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>Metal - 2 画一个三角形</h1><span class=post-meta><i class="fas fa-calendar"></i>&nbsp;发表于 May 29, 2020
&nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;5&nbsp;分钟
&nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;938&nbsp;个字
&nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;Kim</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><aside class=toc-article><nav id=TableOfContents><ul><li><a href=#一整体流程>一、整体流程</a></li><li><a href=#二流程细说>二、流程细说</a><ul><li><a href=#1配置-metal-setupmetal>1、配置 Metal <code>SetupMetal</code></a></li><li><a href=#2配置渲染-layer-setuplayer>2、配置渲染 Layer <code>SetupLayer</code></a></li><li><a href=#3-配置渲染目标-setuprendertarget>3. 配置渲染目标 <code>SetupRenderTarget</code></a></li><li><a href=#4配置渲染管道-setuprenderpipeline>4、配置渲染管道 <code>SetupRenderPipeline</code></a></li><li><a href=#5执行渲染-render>5、执行渲染 <code>Render</code></a></li></ul></li><li><a href=#三function-类似-opengl-的-shader>三、Function （类似 OpenGL 的 shader）</a><ul><li><a href=#1-顶点着色函数-vertex-function>1. 顶点着色函数 Vertex Function</a></li><li><a href=#2-片元着色函数-fragment-function>2. 片元着色函数 Fragment Function</a></li></ul></li><li><a href=#四注意点>四、注意点</a></li></ul></nav></aside><article role=main class=blog-post><p>本篇文章的目标是使用 Metal 渲染一个 <strong>渐变色三角形</strong>。</p><p>可以了解到 Metal 和 Render 相关 Api 的基本使用。</p><p>具体代码可以访问 <a href=https://github.com/SourceKim/MetalTest>仓库</a> 的 <code>1. 三角形</code>。</p><p><img src=https://gitee.com/SourceKim/PictureBed/raw/master/img/metal_triangle.png alt=metal_triangle></p><h2 id=一整体流程>一、整体流程</h2><p>对于 Metal 比较陌生的话，建议对着代码食用。</p><ul><li><p>1、配置 Metal 的基本对象 <code>[self setupMetal]</code></p><ul><li><p>初始化 Device</p></li><li><p>初始化 Command Queue</p></li></ul></li><li><p>2、配置渲染的 Layer <code>[self setupLayer]</code></p><p>设值 <code>CAMetalLayer</code> 的参数</p></li><li><p>3、配置渲染目标 RenderTarget 描述 <code>[self setupRenderTarget]</code></p><p>对 <code>MTLRenderPassDescriptor</code> 对象进行配置，给后面 <strong>初始化 Encoder 使用</strong>，该对象的含义是 <strong>设置渲染目标 buffer 的参数</strong>。</p></li><li><p>4、配置渲染管道 Render Pipeline <code>[self setupRenderPipeline]</code></p><p>对 <code>MTLRenderPipelineState</code> 对象进行配置，会设置到后面的 <strong>Encoder 的 renderPipelineState 属性</strong>。</p><p>在这一步中，会把渲染函数（Vertex Function & Fragment Function）使用起来，也就是设置到 MTLRenderPipelineState 属性中。</p></li><li><p>5、执行渲染 <code>[self render]</code></p><ul><li><p>先获取到当前的 Drawable</p></li><li><p>将当前 Drawable 的 Texture 赋值到渲染目标描述（<code>MTLRenderPassDescriptor</code>）的颜色附着点（<code>colorAttachments[0]</code>）属性的 Texture 上</p></li><li><p>从 queue 中构建 Command Buffer</p></li><li><p>从 Command Buffer 中使用渲染目标描述（<code>MTLRenderPassDescriptor</code>）初始化一个 Encoder</p></li><li><p>配置 Encoder</p><p>Encoder 中需要配置如下的属性：</p><ul><li><p>配置 ViewPort</p></li><li><p>配置 RenderPipelineState （会包括渲染 Function）</p></li><li><p>配置输入数据（这里是顶点位置 & 顶点颜色）</p></li></ul></li><li><p>Encoder 执行绘制图元 （<code>drawPrimitives</code>）</p></li><li><p>将 Command Buffer 和 Drawable 关联起来（<code>presentDrawable</code>）</p></li><li><p>提交 Command Buffer（<code>commit</code>）</p></li></ul></li></ul><p>整一个过程就是如上描述，值得我们去细细品味，我认为有如下的问题需要弄清楚：</p><ul><li><p>每一个对象的作用？</p></li><li><p>Function 和输入数据如何对应？</p></li><li><p>怎么把 CALayer 关联到 Metal？或者说 Metal 是如何 <strong>根据输入数据绘制到</strong> Layer（纹理）上？</p></li><li><p>Prensent 的是时候开始绘制了？或者说绘制什么时候开始的？</p></li></ul><h2 id=二流程细说>二、流程细说</h2><p>对每个流程展开描述一次，包括代码细节和需要注意的地方</p><h3 id=1配置-metal-setupmetal>1、配置 Metal <code>SetupMetal</code></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>setupMetal</span> {
    
    _device <span style=color:#f92672>=</span> MTLCreateSystemDefaultDevice();
    
    _queue <span style=color:#f92672>=</span> [_device newCommandQueue];
}
</code></pre></div><ul><li><p>在 iOS 中，不支持外接 GPU，因此一般 Device 的创建使用 <code>MTLCreateSystemDefaultDevice()</code> 即可。</p></li><li><p>指令队列 Command Queue 的创建依赖于 Device。 对于单线程的 APP，一般创建一个 Queue。</p></li></ul><h3 id=2配置渲染-layer-setuplayer>2、配置渲染 Layer <code>SetupLayer</code></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>setupLayer</span> {
    
    _layer <span style=color:#f92672>=</span> [CAMetalLayer layer];
    _layer.pixelFormat <span style=color:#f92672>=</span> MTLPixelFormatBGRA8Unorm;
    _layer.framebufferOnly <span style=color:#f92672>=</span> true;
    _layer.frame <span style=color:#f92672>=</span> self.view.bounds;
    
    CGFloat scale <span style=color:#f92672>=</span> self.view.contentScaleFactor;
    _layer.drawableSize <span style=color:#f92672>=</span> CGSizeApplyAffineTransform(self.view.bounds.size, CGAffineTransformMakeScale(scale, scale));
    
    [self.view.layer addSublayer: _layer];
}
</code></pre></div><p>要使用 Metal 绘制到 CALayer 上，需要使用 CALayer 的子类 <code>CAMetalLayer</code></p><p>一般我们的像素格式都是用 <code>MTLPixelFormatBGRA8Unorm</code>，即 BGRA 四个颜色分量，每个占 8 位，使用无符号归一化到 0 ~ 1 的值空间。</p><h3 id=3-配置渲染目标-setuprendertarget>3. 配置渲染目标 <code>SetupRenderTarget</code></h3><p>这一步的目的是构建一个 <code>MTLRenderPassDescriptor</code>，即渲染过程描述，该对象会 <strong>告诉后面的 Encoder，它的渲染参数</strong>，因此后续会用来初始化 Encoder。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>    _renderTargetDesc <span style=color:#f92672>=</span> [MTLRenderPassDescriptor renderPassDescriptor];
    MTLRenderPassColorAttachmentDescriptor <span style=color:#f92672>*</span>colorAttachment <span style=color:#f92672>=</span> _renderTargetDesc.colorAttachments[<span style=color:#ae81ff>0</span>];
<span style=color:#75715e>//    colorAttachment.texture = [_layer nextDrawable].texture;
</span><span style=color:#75715e></span>    colorAttachment.loadAction <span style=color:#f92672>=</span> MTLLoadActionClear;
    colorAttachment.storeAction <span style=color:#f92672>=</span> MTLStoreActionStore;
    colorAttachment.clearColor <span style=color:#f92672>=</span> MTLClearColorMake(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>);
</code></pre></div><p>由于这里不需要深度 & 模板测试，因此只需要配置其 ColorAttachment 即可，直接取第一个。</p><p>ColorAttachment 参数：</p><ul><li><p>loadAction 本次渲染的初始动作，是一个枚举，有如下的枚举值：</p><ul><li><p>MTLLoadActionDontCare 不关心</p><blockquote><p>Each pixel in the attachment is allowed to take on any value at the start of the rendering pass.</p></blockquote><p>这个动作会把初始像素设置成 <strong>随机值</strong>。如果我们的这次渲染会覆盖对所有像素点，可以使用这个枚举值。</p></li><li><p>MTLLoadActionClear</p><blockquote><p>A value is written to every pixel in the specified attachment.</p></blockquote><p>会使用 <code>clearColor</code> 提供的颜色去写入所有的像素</p></li><li><p>MTLLoadActionLoad</p><blockquote><p>The existing contents of the texture are preserved.</p></blockquote><p>会保留上一次绘制的像素（纹理）</p></li></ul><p>另外：</p><p>如果是 Color 渲染目标，默认是 MTLLoadActionDontCare，如果是 Depth 或者是 Stencil，默认是 MTLLoadActionClear。</p></li><li><p>storeAction 渲染结束的动作，有如下枚举值：</p><ul><li><p>MTLStoreActionDontCare 在渲染结束之后，把 Attachment 置为未定义状态，该动作会提升性能</p></li><li><p>MTLStoreActionStore 会将渲染结束的结果保留在 Attachment 中</p></li></ul><p>另外还有一些不常用到的，用到再回头记录下：</p><ul><li><p>MTLStoreActionMultisampleResolve</p></li><li><p>MTLStoreActionStoreAndMultisampleResolve</p></li><li><p>MTLStoreActionUnknown</p></li><li><p>MTLStoreActionCustomSampleDepthStore</p></li></ul></li><li><p>clearColor 当 loadAction 为 clear 的时候，会用这里设置的颜色进行清理屏幕</p></li></ul><p>注意，这里我先不设置 texture（注释掉了），等每次渲染的时候再去设置。</p><h3 id=4配置渲染管道-setuprenderpipeline>4、配置渲染管道 <code>SetupRenderPipeline</code></h3><p>这一步的目的是构造一个渲染管道状态 <code>RenderPipelineState</code> 对象给后面的 Encoder 使用，主要是关联我们的两个 Function （Vertex & Fragment）。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>setupRenderPipeline</span> {
    
    <span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>MTLLibrary<span style=color:#f92672>&gt;</span> library <span style=color:#f92672>=</span> [_device newDefaultLibrary];
    
    <span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>MTLFunction<span style=color:#f92672>&gt;</span> vertexFunc <span style=color:#f92672>=</span> [library newFunctionWithName: <span style=color:#e6db74>@&#34;vertexShader&#34;</span>];
    <span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>MTLFunction<span style=color:#f92672>&gt;</span> fragmentFunc <span style=color:#f92672>=</span> [library newFunctionWithName: <span style=color:#e6db74>@&#34;fragmentShader&#34;</span>];
    
    MTLRenderPipelineDescriptor <span style=color:#f92672>*</span>pipelineDescriptor <span style=color:#f92672>=</span> [MTLRenderPipelineDescriptor new];
    pipelineDescriptor.label <span style=color:#f92672>=</span> <span style=color:#e6db74>@&#34;Render Pipeline&#34;</span>;
    pipelineDescriptor.vertexFunction <span style=color:#f92672>=</span> vertexFunc;
    pipelineDescriptor.fragmentFunction <span style=color:#f92672>=</span> fragmentFunc;
    pipelineDescriptor.colorAttachments[<span style=color:#ae81ff>0</span>].pixelFormat <span style=color:#f92672>=</span> _layer.pixelFormat;
    
    NSError <span style=color:#f92672>*</span>err;
    _renderPipelineState <span style=color:#f92672>=</span> [_device newRenderPipelineStateWithDescriptor: pipelineDescriptor error: <span style=color:#f92672>&amp;</span>err];
    
    NSAssert(_renderPipelineState <span style=color:#f92672>!=</span> nil, <span style=color:#e6db74>@&#34;Failed to create pipeline state: %@&#34;</span>, err);
}
</code></pre></div><p>所有的 Metal 文件，最后会被编译到 <code>default.metalib</code> 中，我们可以通过设备的 <code>newDefaultLibrary</code> 获取到这个默认的 Library。编译后的 Function 会在这个默认的 Library 中，可以通过 <code>newFunctionWithName:</code> 输入 <strong>函数名</strong> 找到对应的 Function。</p><p>为了构建渲染管道状态 <code>RenderPipelineState</code> 对象，需要先构造一个渲染管道描述 <code>MTLRenderPipelineDescriptor</code> 对象。</p><p>我们的上面在 Library 中取得的两个 <strong>Function 是关联到 MTLRenderPipelineDescriptor</strong> 上的。</p><p>然后就可以从 device 中构造渲染管道状态对象了，在构造的初始化方法中传入前面的描述对象即可。</p><p>注意构造是有可能会失败的，因此最好在生产环境中判断一下 state 是不是为 nil。</p><h3 id=5执行渲染-render>5、执行渲染 <code>Render</code></h3><p>这一步是 <strong>将我们的 GPU 指令组装到 Encoder 中</strong>，然后通过 <strong>Buffer 将指令送到 GPU 去执行</strong>。</p><p><img src=https://gitee.com/SourceKim/PictureBed/raw/master/img/20200601014123.png alt=Metal-Buffer-Encoder0></p><p>类似于这个小车，就是我们的 <code>Command Buffer</code>，他会不断地将指令从我们的程序 “搬运” 到 GPU 中去执行。</p><p>而上面的 Command 1 2 3，会被封装到我们的 <code>Command Encoder</code> 里面。</p><p><img src=https://gitee.com/SourceKim/PictureBed/raw/master/img/20200601013840.png alt=Metal-Buffer-Encoder></p><p>在 <code>Command Encoder</code> 的 <code>drawPrimitives()</code> 函数之前，都是将 GPU 操作（比如说设置 State、设置输入数据 bytes、texutre 等）“打包” 到我们的 Encoder 中；</p><p>而 <code>Command Encoder</code> 的 <code>endEncoding()</code> 函数，可以被理解成 “装车” 操作，即将 Encoder 放到 <code>Command Buffer</code> 中</p><p>回到我们的工程中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>render</span> {
    
    <span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>CAMetalDrawable<span style=color:#f92672>&gt;</span> currentDrawable <span style=color:#f92672>=</span> [_layer nextDrawable];
    _renderTargetDesc.colorAttachments[<span style=color:#ae81ff>0</span>].texture <span style=color:#f92672>=</span> currentDrawable.texture;
    
    <span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>MTLCommandBuffer<span style=color:#f92672>&gt;</span> commandBuffer <span style=color:#f92672>=</span> [_queue commandBuffer];
    commandBuffer.label <span style=color:#f92672>=</span> <span style=color:#e6db74>@&#34;Command Buffer&#34;</span>;
    
    <span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>MTLRenderCommandEncoder<span style=color:#f92672>&gt;</span> encoder <span style=color:#f92672>=</span> [commandBuffer renderCommandEncoderWithDescriptor: _renderTargetDesc];
    encoder.label <span style=color:#f92672>=</span> <span style=color:#e6db74>@&#34;Render Command Encoder&#34;</span>;
    
    [encoder setViewport: (MTLViewport) {
        .originX <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
        .originY <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
        .width <span style=color:#f92672>=</span> _layer.drawableSize.width,
        .height <span style=color:#f92672>=</span> _layer.drawableSize.height,
        .znear <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
        .zfar <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
    }];
    
    [encoder setRenderPipelineState: _renderPipelineState];
    
    [encoder setVertexBytes: vertices
                     length: <span style=color:#66d9ef>sizeof</span>(vertices)
                    atIndex: <span style=color:#ae81ff>0</span>];
    
    [encoder setVertexBytes: color_data
                     length: <span style=color:#66d9ef>sizeof</span>(color_data)
                    atIndex: <span style=color:#ae81ff>1</span>];
    
    [encoder drawPrimitives: MTLPrimitiveTypeTriangle
                vertexStart: <span style=color:#ae81ff>0</span>
                vertexCount: <span style=color:#ae81ff>3</span>];
    
    [encoder endEncoding];
    
    [commandBuffer presentDrawable: currentDrawable];
    
    [commandBuffer commit];
}
</code></pre></div><ul><li><p><code>[_layer nextDrawable]</code> 从 layer 中获取下一个绘制区，当做这一次绘制的绘制区，这个函数会等待直到 layer 返回下一个可用的绘制区</p></li><li><p>然后将上面的 drawable 赋值到之前配置的渲染过程描述对象(<code>MTLRenderPassDescriptor</code>)的 texture 中 （更新渲染过程描述对象）</p></li><li><p>从 queue 中新建一个 Command Buffer（这个 buffer 不可复用，commit 之后就无效了）</p></li><li><p>使用更新后的渲染过程描述对象（<code>MTLRenderPassDescriptor</code>）构造一个 Command Encoder</p></li><li><p>配置 Command Encoder</p><ul><li>设置可见 ViewPort</li><li>设置顶点数据</li><li>设置颜色数据</li><li>绘制三角形图元 <code>drawPrimitives</code></li></ul></li><li><p>Encoder “装车”，装到 Command Buffer 中 <code>endEncoding</code></p></li><li><p>关联 Command Buffer 到渲染第一步获取的 Drawable 中，即这个 Buffer 会绘制到这个 Drawable 上。<code>presentDrawable</code></p></li><li><p>提交 Command Buffer，类似一个 “发车” 的过程，将 Command Buffer 发送到 GPU 中，等待执行。 <code>commit</code></p></li></ul><p>渲染步骤可以像我上面描述的 “货物装车，发车” 流程，会更加容易理解和记忆。</p><h2 id=三function-类似-opengl-的-shader>三、Function （类似 OpenGL 的 shader）</h2><p>在 XCode 中可以直接新建文件去创建 Metal Funtion 的文件，在 <code>Source</code> 栏里面。</p><p><img src=https://gitee.com/SourceKim/PictureBed/raw/master/img/metal-file.png alt=metal-file></p><p>在编译的时候会执行编译检查，最终打包到 <code>default.metalib</code> 文件中。</p><p><img src=https://gitee.com/SourceKim/PictureBed/raw/master/img/metalib.jpg alt=metalib></p><p>类似于 OpenGL，Metal 的变换流程也类似：从顶点到顶点着色器，再进行光栅化，再进行片元着色最后就会输出像素点到屏幕上：</p><p><img src=https://gitee.com/SourceKim/PictureBed/raw/master/img/20200601021952.png alt=Metal-render></p><h3 id=1-顶点着色函数-vertex-function>1. 顶点着色函数 Vertex Function</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span>
{
    <span style=color:#75715e>// The [[position]] attribute of this member indicates that this value
</span><span style=color:#75715e></span>    <span style=color:#75715e>// is the clip space position of the vertex when this structure is
</span><span style=color:#75715e></span>    <span style=color:#75715e>// returned from the vertex function.
</span><span style=color:#75715e></span>    float4 position [[position]];

    <span style=color:#75715e>// Since this member does not have a special attribute, the rasterizer
</span><span style=color:#75715e></span>    <span style=color:#75715e>// interpolates its value with the values of the other triangle vertices
</span><span style=color:#75715e></span>    <span style=color:#75715e>// and then passes the interpolated value to the fragment shader for each
</span><span style=color:#75715e></span>    <span style=color:#75715e>// fragment in the triangle.
</span><span style=color:#75715e></span>    float4 color;

} VertexOut;

vertex VertexOut
<span style=color:#a6e22e>vertexShader</span>(uint vertexID [[ vertex_id ]],
             constant float4 <span style=color:#f92672>*</span>position [[ buffer(<span style=color:#ae81ff>0</span>) ]],
             constant float4 <span style=color:#f92672>*</span>color [[ buffer(<span style=color:#ae81ff>1</span>) ]]
             )
{
    VertexOut <span style=color:#66d9ef>out</span>;
    
    <span style=color:#66d9ef>out</span>.position <span style=color:#f92672>=</span> position[vertexID];
    <span style=color:#66d9ef>out</span>.color <span style=color:#f92672>=</span> color[vertexID];
    
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>out</span>;
}
</code></pre></div><ul><li><p>顶点着色器函数的定义以 <code>vertex</code> 标记开头；</p></li><li><p>一般会 <strong>返回值是一个结构体</strong>，会 <strong>插值之后</strong> 传到给片元着色函数</p><ul><li><p>该结构体中我们会使用 <code>[[position]]</code> 去标记 <strong>顶点在裁剪空间的位置</strong>。类似于 OpenGL 中的 <code>gl_FragPos=xxxx</code></p></li><li><p>其他的需要插值的变量也会定义在这里，但是不需要标记。类似于 OpenGL 中的 <code>varying</code></p></li></ul></li><li><p>在传入的参数中，会有一个 <strong>默认的 id 参数</strong>，使用 <code>[[ vertex_id ]]</code> 标记，这个参数会告诉我们当前作用的是 <strong>第几个顶点</strong>。</p><p>比如这里我们有 3 个顶点，3 个颜色数组，在取值的时候可以直接使用 <code>[[ vertex_id ]]</code> 标记的参数变量作为索引，去访问传入的数据指针。</p></li><li><p>在传入的参数中，其他的 bytes 参数或者 buffer 参数，都会使用 <code>[[ buffer(n) ]]</code> 来标记，具体对应 encoder 提交指令的 index。</p><p>注意我们传入的 position 是一个 4 * 3 = 12 个 float 的指针，在这里就 <strong>自动转变成了</strong> 3 个 float4 的指针。color 同理。</p></li></ul><p>然后像普通函数一样，声明、赋值、return 即可。</p><h3 id=2-片元着色函数-fragment-function>2. 片元着色函数 Fragment Function</h3><p>在顶点着色函数的返回值 <code>VertexOut</code> 经过系统内部的光栅化会对其返回值进行插值处理，最后会将插值后的顶点着色函数的返回值传递到这儿 - 片元着色函数，作为其参数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>fragment float4
<span style=color:#a6e22e>fragmentShader</span>(VertexOut fragmentIn [[ stage_in ]])
{
    <span style=color:#66d9ef>return</span> fragmentIn.color;
}
</code></pre></div><ul><li><p>片元着色函数的定义以 <code>fragment</code> 开头</p></li><li><p>返回值一般是 float4，代表这个 <strong>片元的渲染颜色</strong></p></li><li><p>片元着色函数可以接收从顶点着色函数返回值光栅化后的结构体，使用 <code>[[ stage_in ]]</code> 标记。</p></li></ul><p>在我们这里直接使用插值后的 color 输出，即可得到渐变的三角形。</p><h2 id=四注意点>四、注意点</h2><p>在 Metal 中,为了避免 <strong>内存对齐</strong> 导致的问题，定义 position 和 color 两个顶点着色函数输入的时候直接使用了 4 个 float 为一组的定义方式：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> vertices[] <span style=color:#f92672>=</span> {
    <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0.5</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>,
    <span style=color:#f92672>-</span><span style=color:#ae81ff>0.5</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.5</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>,
    <span style=color:#ae81ff>0.5</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.5</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>,
};

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> color_data[] <span style=color:#f92672>=</span> {
    <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>,
    <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>,
    <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>,
};
</code></pre></div><p>这样在 <strong>simd 转换成 float4</strong> 的时候就能避免内存对齐产生的问题，具体原因和应对方式以后可以展开讨论。</p><div class=blog-tags><a href=https://www.uiimage.com//tags/ios/>iOS</a>&nbsp;
<a href=https://www.uiimage.com//tags/metal/>Metal</a>&nbsp;
<a href=https://www.uiimage.com//tags/%E9%9F%B3%E8%A7%86%E9%A2%91/>音视频</a>&nbsp;</div><hr><section id=social-share><div class="list-inline footer-links"><div class=share-box aria-hidden=true><ul class=share><li><a href="//twitter.com/share?url=https%3a%2f%2fwww.uiimage.com%2fpost%2fblog%2fmetal%2fmetal-2-draw-a-triangle%2f&text=Metal%20-%202%20%e7%94%bb%e4%b8%80%e4%b8%aa%e4%b8%89%e8%a7%92%e5%bd%a2&via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter"></i></a></li><li><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.uiimage.com%2fpost%2fblog%2fmetal%2fmetal-2-draw-a-triangle%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook"></i></a></li><li><a href="//reddit.com/submit?url=https%3a%2f%2fwww.uiimage.com%2fpost%2fblog%2fmetal%2fmetal-2-draw-a-triangle%2f&title=Metal%20-%202%20%e7%94%bb%e4%b8%80%e4%b8%aa%e4%b8%89%e8%a7%92%e5%bd%a2" target=_blank title="Share on Reddit"><i class="fab fa-reddit"></i></a></li><li><a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fwww.uiimage.com%2fpost%2fblog%2fmetal%2fmetal-2-draw-a-triangle%2f&title=Metal%20-%202%20%e7%94%bb%e4%b8%80%e4%b8%aa%e4%b8%89%e8%a7%92%e5%bd%a2" target=_blank title="Share on LinkedIn"><i class="fab fa-linkedin"></i></a></li><li><a href="//www.stumbleupon.com/submit?url=https%3a%2f%2fwww.uiimage.com%2fpost%2fblog%2fmetal%2fmetal-2-draw-a-triangle%2f&title=Metal%20-%202%20%e7%94%bb%e4%b8%80%e4%b8%aa%e4%b8%89%e8%a7%92%e5%bd%a2" target=_blank title="Share on StumbleUpon"><i class="fab fa-stumbleupon"></i></a></li><li><a href="//www.pinterest.com/pin/create/button/?url=https%3a%2f%2fwww.uiimage.com%2fpost%2fblog%2fmetal%2fmetal-2-draw-a-triangle%2f&description=Metal%20-%202%20%e7%94%bb%e4%b8%80%e4%b8%aa%e4%b8%89%e8%a7%92%e5%bd%a2" target=_blank title="Share on Pinterest"><i class="fab fa-pinterest"></i></a></li></ul></div></div></section><h4 class=see-also>也可以看看</h4><ul><li><a href=/post/blog/metal/metal-10-phong-lighting/>Metal - 10 光照（冯氏光照模型）</a></li><li><a href=/post/blog/metal/metal-9-render-camera-yuv-by-texture-cache/>Metal - 9 渲染摄像头采集的 YUV(YCbCr) 数据（CVMetalTextureCacheRef）</a></li><li><a href=/post/blog/metal/metal-8-render-camera-bgra-by-texture-cache/>Metal - 8 渲染摄像头采集的 BGRA 数据（CVMetalTextureCacheRef）</a></li><li><a href=/post/blog/metal/metal-7-rotatingcube/>Metal - 7 旋转的立方体</a></li><li><a href=/post/blog/metal/metal-6-three-dimentions-transformation/>Metal - 6 三维变换</a></li></ul></article><ul class="pager blog-pager"><li class=previous><a href=https://www.uiimage.com/post/blog/opengl-es/opengl-es-13-blending/ data-toggle=tooltip data-placement=top title="OpenGL ES in iOS - 13 混合 blending">&larr; 前一篇</a></li><li class=next><a href=https://www.uiimage.com/post/blog/metal/metal-3-draw-a-picture/ data-toggle=tooltip data-placement=top title="Metal - 3 画一个图片">后一篇 &rarr;</a></li></ul><span id=/post/blog/metal/metal-2-draw-a-triangle/ class=leancloud_visitors data-flag-title="Metal - 2 画一个三角形"><p></p></span><div id=vcomments></div><script src=//cdn1.lncld.net/static/js/3.0.4/av-min.js></script><script src=//unpkg.com/valine/dist/Valine.min.js></script><script type=text/javascript>new Valine({el:'#vcomments',appId:'Ld2PPgvVUNucDd8KP4B0kNNB-gzGzoHsz',appKey:'rijpKLUzykFXX0DGsbzHezk5',notify:false,verify:false,avatar:'robohash',placeholder:'有不当之处，求大佬指正~',visitor:false});</script></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:18666269733@163.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/SourceKim title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted"><a href=https://uiimage.com>Kim</a>
&nbsp;&bull;&nbsp;&copy;
2020
&nbsp;&bull;&nbsp;
<a href=https://www.uiimage.com/>Kim's Blog</a></p><p class="credits theme-by text-muted">由 <a href=https://gohugo.io>Hugo v0.69.2</a> 强力驱动 &nbsp;&bull;&nbsp; 主题 <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> 移植自 <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe crossorigin=anonymous></script><script src=https://code.jquery.com/jquery-1.12.4.min.js integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=https://www.uiimage.com/js/main.js></script><script>renderMathInElement(document.body);</script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js integrity=sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js integrity=sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q crossorigin=anonymous></script><script src=https://www.uiimage.com/js/load-photoswipe.js></script></body></html>