<!doctype html><html lang=zh itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>iOS 硬编码硬解码 1 - 介绍 - Kim's Blog</title><meta name=description content="包含如下内容


编解码基础知识简介（一些名词术语的解释）


VideoToolbox 介绍（编码 & 解码 api）


H264 的数据格式"><meta name=author content="Kim"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Kim\x27s Blog","url":"https:\/\/www.uiimage.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/www.uiimage.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/www.uiimage.com\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/www.uiimage.com\/post\/blog\/videotoolbox\/ios-videotoolbox-codec-1\/","name":"I o s 硬编码硬解码 1 介绍"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Kim"},"headline":"iOS 硬编码硬解码 1 - 介绍","description":"包含如下内容\n  编解码基础知识简介（一些名词术语的解释）\n  VideoToolbox 介绍（编码 \x26amp; 解码 api）\n  H264 的数据格式\n ","inLanguage":"zh","wordCount":1082,"datePublished":"2019-06-19T23:00:00","dateModified":"2019-06-19T23:00:00","image":"https:\/\/www.uiimage.com\/img\/avatar.JPG","keywords":["iOS, 音视频, VideoToolbox"],"mainEntityOfPage":"https:\/\/www.uiimage.com\/post\/blog\/videotoolbox\/ios-videotoolbox-codec-1\/","publisher":{"@type":"Organization","name":"https:\/\/www.uiimage.com\/","logo":{"@type":"ImageObject","url":"https:\/\/www.uiimage.com\/img\/avatar.JPG","height":60,"width":60}}}</script><meta property="og:title" content="iOS 硬编码硬解码 1 - 介绍"><meta property="og:description" content="包含如下内容


编解码基础知识简介（一些名词术语的解释）


VideoToolbox 介绍（编码 & 解码 api）


H264 的数据格式"><meta property="og:image" content="https://www.uiimage.com/img/avatar.JPG"><meta property="og:url" content="https://www.uiimage.com/post/blog/videotoolbox/ios-videotoolbox-codec-1/"><meta property="og:type" content="website"><meta property="og:site_name" content="Kim's Blog"><meta name=twitter:title content="iOS 硬编码硬解码 1 - 介绍"><meta name=twitter:description content="包含如下内容


编解码基础知识简介（一些名词术语的解释）


VideoToolbox 介绍（编码 & 解码 api）


H264 的数据格式"><meta name=twitter:image content="https://www.uiimage.com/img/avatar.JPG"><meta name=twitter:card content="summary"><link href=https://www.uiimage.com/img/avatar.JPG rel=icon type=image/x-icon><meta name=generator content="Hugo 0.69.2"><link rel=alternate href=https://www.uiimage.com/index.xml type=application/rss+xml title="Kim's Blog"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://www.uiimage.com/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://www.uiimage.com/css/syntax.css><link rel=stylesheet href=https://www.uiimage.com/css/codeblock.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css integrity=sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css integrity=sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>切换导航</span>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button>
<a class=navbar-brand href=https://www.uiimage.com/>Kim's Blog</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Home href=/>Home</a></li><li><a title=Tags href=/tags>Tags</a></li><li><a title=About href=/page/about/>About</a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Kim's Blog" href=https://www.uiimage.com/><img class=avatar-img src=https://www.uiimage.com/img/avatar.JPG alt="Kim's Blog"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>iOS 硬编码硬解码 1 - 介绍</h1><span class=post-meta><i class="fas fa-calendar"></i>&nbsp;发表于 June 19, 2019
&nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;6&nbsp;分钟
&nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;1082&nbsp;个字
&nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;Kim</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><aside class=toc-article><nav id=TableOfContents><ul><li><a href=#一基础知识>一、基础知识</a></li><li><a href=#二videotoolbox-介绍>二、VideoToolbox 介绍</a><ul><li><a href=#编码>编码</a></li><li><a href=#解码>解码</a></li></ul></li><li><a href=#三h264-数据格式>三、H264 数据格式</a></li></ul></nav></aside><article role=main class=blog-post><p>包含如下内容</p><ul><li><p>编解码基础知识简介（一些名词术语的解释）</p></li><li><p>VideoToolbox 介绍（编码 & 解码 api）</p></li><li><p>H264 的数据格式</p></li></ul><h2 id=一基础知识>一、基础知识</h2><p>在进行视频数据的传输中，为了保证传输的效率，需要将数据进行压缩，常用的压缩格式有 H264（AVCC）和 H265（HEVC）。</p><p><img src=https://gitee.com/SourceKim/PictureBed/raw/master/img/20200621144239.png alt></p><p>视频的提供方通过将数据压缩，然后使用网络传输出去到达其他接收方，接收方通过解码即可还原视频，最后渲染上屏。</p><p>iOS 有专用的编码模块，可以快速地将数据编码，并且不占用 CPU 资源，这也是相比于软编软解的优势，劣势就是 VideoToolbox 是 iOS8.0 之后才有的，因此不兼容低版本。</p><p>这里有一些整理的基本概念：</p><table><thead><tr><th align=center>概念</th><th align=center>含义</th></tr></thead><tbody><tr><td align=center>I 帧 (Intra-coded)</td><td align=center>关键帧，会进行帧内编码，编码的时候不参考其他帧</td></tr><tr><td align=center>P 帧 (Predictive)</td><td align=center>预测帧，会进行帧间编码，编码的时候参考前面的 I 帧或者 P 帧，保留运动预测的信息</td></tr><tr><td align=center>B 帧 (Bidirectionally-predicted)</td><td align=center>双向预测帧，也是帧间编码，编码的时候参考前面的 I 帧或者 P 帧，以及后面的 P 帧,保留运动预测的信息</td></tr><tr><td align=center>IDR 帧 (Instantaneous Decoding Refresh)</td><td align=center>立即刷新的帧，是 <strong>第一个 I 帧</strong>，区别于其他 I 帧，该帧会立即刷新运动预测的参考列表清空</td></tr><tr><td align=center>GOP (Group of Pictures)</td><td align=center>一组图像，包含一个 I 帧以及多个 P 帧和 B 帧。一般可以用以表达 <strong>两个 I 帧的距离</strong>，比如说 10 个，说明每个 I 帧之间中共间隔 10 个 P 帧和 B 帧。如果为 10 秒，即两个关键帧之间最多间隔 10 秒</td></tr><tr><td align=center>码率 (Bitrate)</td><td align=center>单位时间内传输的数据量，一般单位是 bps / kbps，即每秒中传输位数或千位数。传输数据越多，视频质量越高</td></tr><tr><td align=center>帧率 FPS (frame per second)</td><td align=center>每秒播放的帧数</td></tr><tr><td align=center>分辨率 (Resolution)</td><td align=center>一帧的像素的大小，一般是 宽X高 表示</td></tr><tr><td align=center>SPS (Sequence Parameter Sets)</td><td align=center>序列参数信息集，主要包含帧间预测相关的信息（包括 Profile、level、宽高等）</td></tr><tr><td align=center>PPS (Picture Parameter Set)</td><td align=center>图像参数信息集，主要包含对图像的信息（包括）</td></tr><tr><td align=center>SEI (Supplementary Enhancement Information)</td><td align=center>增强信息，包括帮助补充和增加解码相关的信息</td></tr><tr><td align=center>Slice</td><td align=center>数据片，也就是我们图像信息的帧，包括 I 片（I-Slice）、P 片（P-Slice）、B 片（B-Slice）</td></tr><tr><td align=center>NALU (Network Abstraction Layer Unit)</td><td align=center>H264 传输单元，一个单元内可能包含参数信息（SPS / PPS / SEI），或者帧片段（I-Slice / P-Slice / B-Slice）</td></tr></tbody></table><p>编码还有一个码率类型参数，用以在不同情况的时候调节码率的策略。</p><table><thead><tr><th align=center>码率类型</th><th align=center>含义</th><th align=center>场景</th></tr></thead><tbody><tr><td align=center>CBR (Constant BitRate)</td><td align=center>固定比特率，即编码使保持码率不变</td><td align=center>直播场景，因为稳定，不容易卡顿</td></tr><tr><td align=center>ABR (Constant BitRate)</td><td align=center>平均比特率，保持码率在一个平均值</td><td align=center>直播场景，因为稳定，不容易卡顿</td></tr><tr><td align=center>VBR (Variable BitRate)</td><td align=center>可变码率，随着图像的复杂度而自行调整码率</td><td align=center>短视频、存储等，因为这样可以高度保障图片的信息</td></tr><tr><td align=center>CVBR (Constrained Variable BitRate)</td><td align=center>被约束的可变码率，为可变码率增加一个约束</td><td align=center>无</td></tr></tbody></table><p>对于不同场景，对于编码 Profile 的级别也可以有不同的选择：</p><table><thead><tr><th align=center>Profile 级别</th><th align=center>描述</th><th align=center>场景</th></tr></thead><tbody><tr><td align=center>Baseline</td><td align=center>最低级别。仅 I 帧和 P 帧，无 B 帧</td><td align=center>视频通话</td></tr><tr><td align=center>Main</td><td align=center>主要级别。包括 I 帧、P 帧和 B 帧</td><td align=center>直播</td></tr><tr><td align=center>High</td><td align=center>最高级别。包括 I 帧、P 帧和 B 帧，增加 8x8 内部预测，支持无损编码</td><td align=center>用以高质量的视频存储</td></tr></tbody></table><h2 id=二videotoolbox-介绍>二、VideoToolbox 介绍</h2><p>iOS 的硬编码 & 硬解码使用 VideoToolbox framework 实现。</p><p>VideoToolbox 的功能只有 编码 & 解码</p><p>因此其 api 也围绕他们：</p><h3 id=编码>编码</h3><p><code>VTCompressionSessionRef</code> 编码会话，是编码流程的核心。</p><ul><li><p>1、创建会话</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>VT_EXPORT OSStatus 
<span style=color:#a6e22e>VTCompressionSessionCreate</span>(
    CM_NULLABLE CFAllocatorRef							allocator,
    int32_t												width,
    int32_t												height,
    CMVideoCodecType									codecType,
    CM_NULLABLE CFDictionaryRef							encoderSpecification,
    CM_NULLABLE CFDictionaryRef							sourceImageBufferAttributes,
    CM_NULLABLE CFAllocatorRef							compressedDataAllocator,
    CM_NULLABLE VTCompressionOutputCallback				outputCallback,
    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> CM_NULLABLE									outputCallbackRefCon,
    CM_RETURNS_RETAINED_PARAMETER CM_NULLABLE VTCompressionSessionRef <span style=color:#f92672>*</span> CM_NONNULL compressionSessionOut) API_AVAILABLE(macosx(<span style=color:#ae81ff>10.8</span>), ios(<span style=color:#ae81ff>8.0</span>), tvos(<span style=color:#ae81ff>10.2</span>));
</code></pre></div><ul><li><p>allocator 分配器，一般传入 NULL 或者 <code>kCFAllocatorDefault</code></p></li><li><p>width 帧的宽度</p></li><li><p>height 帧的高度</p></li><li><p>codecType 编码类型，对于视频来说，一般是 H264（<code>kCMVideoCodecType_H264</code>）或者 H265（<code>kCMVideoCodecType_HEVC</code>）</p></li><li><p>encoderSpecification 编码参数，可为 <code>NULL</code></p></li><li><p>sourceImageBufferAttributes 源 buffer 的属性， <code>NULL</code></p></li><li><p>compressedDataAllocator 压缩数据的内存分配器，一般是 <code>NULL</code></p></li><li><p>outputCallback 输出的回调，是一个 <strong>C 函数指针</strong>，类型是 <code>VTCompressionOutputCallback</code></p><p>编码回调函数这么定义，是一个 C 函数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>void</span> (<span style=color:#f92672>*</span>VTCompressionOutputCallback)(
<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> CM_NULLABLE outputCallbackRefCon,
<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> CM_NULLABLE sourceFrameRefCon, 
OSStatus status, 
VTEncodeInfoFlags infoFlags,
CM_NULLABLE CMSampleBufferRef sampleBuffer );
</code></pre></div><p>最后一个参数 <code>sampleBuffer</code>，就是编码得到的结果。</p></li><li><p>outputCallbackRefCon 输出回调中 <code>outputCallbackRefCon</code> 参数的指针。一般传入 self，这样就可以在 C 回调获取到本对象的地址，进行操作</p></li><li><p>compressionSessionOut 所创建的 session 保存的指针，一般在外部声明，然后通过 <code>&</code> 传入</p></li></ul></li><li><p>2、设置编码器会话参数</p><p>编码器会话的参数可以通过</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>VT_EXPORT OSStatus 
<span style=color:#a6e22e>VTSessionSetProperty</span>(
CM_NONNULL VTSessionRef       session,
CM_NONNULL CFStringRef        propertyKey,
CM_NULLABLE CFTypeRef         propertyValue ) API_AVAILABLE(macosx(<span style=color:#ae81ff>10.8</span>), ios(<span style=color:#ae81ff>8.0</span>), tvos(<span style=color:#ae81ff>10.2</span>));
</code></pre></div><ul><li>session 会话</li><li>propertyKey 参数的 key</li><li>propertyValue 参数的 value</li></ul><p>可以设置 FPS、GOP、码率等参数，后续会详细介绍。</p></li><li><p>3、准备编码</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>VT_EXPORT OSStatus
<span style=color:#a6e22e>VTCompressionSessionPrepareToEncodeFrames</span>( CM_NONNULL VTCompressionSessionRef session ) API_AVAILABLE(macosx(<span style=color:#ae81ff>10.9</span>), ios(<span style=color:#ae81ff>8.0</span>), tvos(<span style=color:#ae81ff>10.2</span>));
</code></pre></div><p>在编码之前 <strong>必须调用该方法</strong>，告知 session 要准备编码。</p><p>该方法一般在 <strong>设置了参数之后调用</strong>，通过返回值判断是否有异常。</p></li><li><p>4、开始编码</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>VT_EXPORT OSStatus
<span style=color:#a6e22e>VTCompressionSessionEncodeFrame</span>(
    CM_NONNULL VTCompressionSessionRef	session,
    CM_NONNULL CVImageBufferRef			imageBuffer,
    CMTime								presentationTimeStamp,
    CMTime								duration, <span style=color:#75715e>// may be kCMTimeInvalid
</span><span style=color:#75715e></span>    CM_NULLABLE CFDictionaryRef			frameProperties,
    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> CM_NULLABLE					sourceFrameRefcon,
    VTEncodeInfoFlags <span style=color:#f92672>*</span> CM_NULLABLE		infoFlagsOut ) API_AVAILABLE(macosx(<span style=color:#ae81ff>10.8</span>), ios(<span style=color:#ae81ff>8.0</span>), tvos(<span style=color:#ae81ff>10.2</span>));
</code></pre></div><ul><li><p>session 本次编码的会话</p></li><li><p>imageBuffer 要编码的 buffer</p></li><li><p>presentationTimeStamp 展示时间戳。每次编码，为了使结果有序，该值需要一个递增的值。</p><p>可以记录一个变量，每次编码都递增</p><pre><code>CMTime presentationTimeStamp = CMTimeMake(_frameCnt, 1);
_frameCnt++;
</code></pre></li><li><p>duration 帧的播放时长 <code>CMSampleBufferGetOutputDuration(sampleBuffer);</code> 可以通过该 api 获取</p></li><li><p>frameProperties 帧属性，如无要求传入 <code>NULL</code></p></li><li><p>sourceFrameRefcon 源帧的引用，在编码回调的第二个参数的引用，一般传入要编码的 buffer，即和第二个参数相同</p></li><li><p>infoFlagsOut 输出的编码信息，在编码回调的 <code>infoFlags</code>，如果传入 <code>NULL</code>，就代表不会接收到该信息。</p></li></ul><p>另外：开始编码还存在一个包含 <code>outputHandler</code> 的方法，本文先不作介绍。</p></li></ul><h3 id=解码>解码</h3><p>解码会话 <code>VTDecompressionSessionRef</code>。</p><p>VideoToolbox 解码只能解码 <code>CMBlockBufferRef</code> 创建的 <code>CMSampleBuffer</code> 对象，因此我们要将收到的数据先封装成 <code>CMBlockBufferRef</code>，再转化成 <code>CMSampleBuffer</code>，才能进行解码。</p><p><img src=https://gitee.com/SourceKim/PictureBed/raw/master/img/20200621232622.png alt></p><p>使用左边包含 CMBlockBuffer 的 CMSampleBuffer 解码，才能得到右边的包含 <code>CVPixelBuffer</code> 的 CMSampleBuffer。</p><p>流程如下：</p><pre><code>Data =&gt; CMBlockBuffer

CMBlockBuffer =&gt; CMSampleBuffer

CMSampleBuffer(`CMBlockBuffer`) =&gt; CMSampleBuffer(`CVPixelBuffer`)
</code></pre><ul><li><p>1、创建会话</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>VT_EXPORT OSStatus 
<span style=color:#a6e22e>VTDecompressionSessionCreate</span>(
    CM_NULLABLE CFAllocatorRef                              allocator,
    CM_NONNULL CMVideoFormatDescriptionRef					videoFormatDescription,
    CM_NULLABLE CFDictionaryRef								videoDecoderSpecification,
    CM_NULLABLE CFDictionaryRef                             destinationImageBufferAttributes,
    <span style=color:#66d9ef>const</span> VTDecompressionOutputCallbackRecord <span style=color:#f92672>*</span> CM_NULLABLE outputCallback,
    CM_RETURNS_RETAINED_PARAMETER CM_NULLABLE VTDecompressionSessionRef <span style=color:#f92672>*</span> CM_NONNULL decompressionSessionOut) API_AVAILABLE(macosx(<span style=color:#ae81ff>10.8</span>), ios(<span style=color:#ae81ff>8.0</span>), tvos(<span style=color:#ae81ff>10.2</span>));
</code></pre></div><ul><li><p>allocator 内存分配器，一般为 <code>NULL</code></p></li><li><p>videoFormatDescription 视频格式描述对象，通过 SPS & PPS 来构造 （TODO: 下面会详细说明）</p></li><li><p>videoDecoderSpecification 解码器属性，可以指定得到的 buffer 的 pixelFormat，以及 OpenGL & Metal 相关的支持</p></li><li><p>outputCallback 输出回调</p><p>包含一个 <strong>函数指针，以及一个回调对象</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=color:#66d9ef>struct</span> VTDecompressionOutputCallbackRecord {
    CM_NULLABLE VTDecompressionOutputCallback  decompressionOutputCallback;
    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> CM_NULLABLE                         decompressionOutputRefCon;
};
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> VTDecompressionOutputCallbackRecord VTDecompressionOutputCallbackRecord;
</code></pre></div><p>其中函数指针 <code>VTDecompressionOutputCallback</code> 的定义：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>void</span> (<span style=color:#f92672>*</span>VTDecompressionOutputCallback)(
<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> CM_NULLABLE decompressionOutputRefCon,
<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> CM_NULLABLE sourceFrameRefCon,
OSStatus status, 
VTDecodeInfoFlags infoFlags,
CM_NULLABLE CVImageBufferRef imageBuffer,
CMTime presentationTimeStamp, 
CMTime presentationDuration );
</code></pre></div><p>而回调对象一般都设置为 <code>self</code>，用以操作我们的封装的对象</p></li><li><p>decompressionSessionOut 创建的 session 的地址</p></li></ul></li><li><p>2、创建 <code>CMBlockBufferRef</code>。 Data => CMBlockBuffer</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>CM_EXPORT OSStatus	<span style=color:#a6e22e>CMBlockBufferCreateWithMemoryBlock</span>(
    CFAllocatorRef CM_NULLABLE structureAllocator,
    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> CM_NULLABLE memoryBlock,
    size_t blockLength,
    CFAllocatorRef CM_NULLABLE blockAllocator,
    <span style=color:#66d9ef>const</span> CMBlockBufferCustomBlockSource <span style=color:#f92672>*</span> CM_NULLABLE customBlockSource,
    size_t offsetToData, 
    size_t dataLength,
    CMBlockBufferFlags flags, 
    CM_RETURNS_RETAINED_PARAMETER CMBlockBufferRef CM_NULLABLE <span style=color:#f92672>*</span> CM_NONNULL blockBufferOut)
                        API_AVAILABLE(macos(<span style=color:#ae81ff>10.7</span>), ios(<span style=color:#ae81ff>4.0</span>), tvos(<span style=color:#ae81ff>9.0</span>), watchos(<span style=color:#ae81ff>6.0</span>));
</code></pre></div><ul><li>structureAllocator 内存分配器，一般传入 <code>NULL</code></li><li>memoryBlock 编码数据的内存地址</li><li>blockLength 内存的长度</li><li>blockAllocator block buffer 的内存分配器，注意 <strong>此处一定要使用 <code>kCFAllocatorNull</code></strong></li><li>customBlockSource 自定义的 block buffer 资源，一般传入 <code>NULL</code></li><li>offsetToData 数据的字节偏移，一般是 0</li><li>dataLength 数据的长度，和 blockLength 一致</li><li>flags 内存的描述，无特殊需求传入 0 即可</li><li>blockBufferOut 输出的 <code>CMBlockBufferRef</code> 引用</li></ul></li><li><p>3、使用 <code>CMBlockBufferRef</code> 创建包含他的 <code>CMSampleBuffer</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>CM_EXPORT
OSStatus <span style=color:#a6e22e>CMSampleBufferCreateReady</span>(
    CFAllocatorRef CM_NULLABLE allocator,					<span style=color:#75715e>/*! @param allocator
</span><span style=color:#75715e>                                                                The allocator to use for allocating the CMSampleBuffer object.
</span><span style=color:#75715e>                                                                Pass kCFAllocatorDefault to use the default allocator. */</span>
    CMBlockBufferRef CM_NULLABLE dataBuffer,					<span style=color:#75715e>/*! @param dataBuffer
</span><span style=color:#75715e>                                                                CMBlockBuffer that already contains the media data. Must not be NULL. */</span>
    CMFormatDescriptionRef CM_NULLABLE formatDescription,	<span style=color:#75715e>/*! @param formatDescription
</span><span style=color:#75715e>                                                                A description of the media data&#39;s format. Can be NULL. */</span>
    CMItemCount numSamples,									<span style=color:#75715e>/*! @param numSamples
</span><span style=color:#75715e>                                                                Number of samples in the CMSampleBuffer. Can be 0. */</span>
    CMItemCount numSampleTimingEntries,						<span style=color:#75715e>/*! @param numSampleTimingEntries
</span><span style=color:#75715e>                                                                Number of entries in sampleTimingArray. Must be 0, 1, or numSamples. */</span>
    <span style=color:#66d9ef>const</span> CMSampleTimingInfo <span style=color:#f92672>*</span> CM_NULLABLE sampleTimingArray,<span style=color:#75715e>/*! @param sampleTimingArray
</span><span style=color:#75715e>                                                                Array of CMSampleTimingInfo structs, one struct per sample.
</span><span style=color:#75715e>                                                                If all samples have the same duration and are in presentation order, you can pass a single
</span><span style=color:#75715e>                                                                CMSampleTimingInfo struct with duration set to the duration of one sample, presentationTimeStamp
</span><span style=color:#75715e>                                                                set to the presentation time of the numerically earliest sample, and decodeTimeStamp set to
</span><span style=color:#75715e>                                                                kCMTimeInvalid. Behaviour is undefined if samples in a CMSampleBuffer (or even in multiple
</span><span style=color:#75715e>                                                                buffers in the same stream)</span> have the same presentationTimeStamp. Can be NULL. <span style=color:#960050;background-color:#1e0010>*/</span>
    CMItemCount numSampleSizeEntries,						<span style=color:#75715e>/*! @param numSampleSizeEntries
</span><span style=color:#75715e>                                                                Number of entries in sampleSizeArray. Must be 0, 1, or numSamples. */</span>
    <span style=color:#66d9ef>const</span> size_t <span style=color:#f92672>*</span> CM_NULLABLE sampleSizeArray,				<span style=color:#75715e>/*! @param sampleSizeArray
</span><span style=color:#75715e>                                                                Array of size entries, one entry per sample. If all samples have the
</span><span style=color:#75715e>                                                                same size, you can pass a single size entry containing the size of one sample. Can be NULL. Must be
</span><span style=color:#75715e>                                                                NULL if the samples are non-contiguous in the buffer (eg. non-interleaved audio, where the channel
</span><span style=color:#75715e>                                                                values for a single sample are scattered through the buffer). */</span>
    CM_RETURNS_RETAINED_PARAMETER CMSampleBufferRef CM_NULLABLE <span style=color:#f92672>*</span> CM_NONNULL sampleBufferOut)		<span style=color:#75715e>/*! @param sampleBufferOut
</span><span style=color:#75715e>                                                                Returned newly created CMSampleBuffer. */</span>
                            API_AVAILABLE(macos(<span style=color:#ae81ff>10.10</span>), ios(<span style=color:#ae81ff>8.0</span>), tvos(<span style=color:#ae81ff>9.0</span>), watchos(<span style=color:#ae81ff>6.0</span>));
</code></pre></div><ul><li>allocator 内存分配器，一般传入 <code>NULL</code></li><li>dataBuffer 上一步创建的 <code>CMBlockBufferRef</code></li><li>formatDescription 描述对象，解码得到的 pps & sps 数据组装成的 <code>CMFormatDescriptionRef</code> 对象</li><li>numSamples Buffer 中样本的数量，一般为 1</li><li>numSampleTimingEntries 时间入口的数量，一般传入 0</li><li>sampleTimingArray 时间入口数组，一般传入 <code>NULL</code></li><li>sampleSizeArray 样本的间隔数组，一般 1</li><li>sampleBufferOut 输出的 <code>CMSampleBuffer</code> 引用</li></ul></li><li><p>4、开始解码。CMSampleBuffer => CVPixelBuffer（CVImageBuffer）</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>VT_EXPORT OSStatus
<span style=color:#a6e22e>VTDecompressionSessionDecodeFrame</span>(
    CM_NONNULL VTDecompressionSessionRef	session,
    CM_NONNULL CMSampleBufferRef			sampleBuffer,
    VTDecodeFrameFlags						decodeFlags, <span style=color:#75715e>// bit 0 is enableAsynchronousDecompression
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> CM_NULLABLE						sourceFrameRefCon,
    VTDecodeInfoFlags <span style=color:#f92672>*</span> CM_NULLABLE 		infoFlagsOut) API_AVAILABLE(macosx(<span style=color:#ae81ff>10.8</span>), ios(<span style=color:#ae81ff>8.0</span>), tvos(<span style=color:#ae81ff>10.2</span>));
</code></pre></div><ul><li>session 解码会话</li><li>sampleBuffer 上一步创建的 <code>CMSampleBuffer</code></li><li>decodeFlags 如果需要同步解码，传入 0 即可，异步的话可以传入 <code>kVTDecodeFrame_EnableAsynchronousDecompression</code></li><li>sourceFrameRefCon 解码的 <code>CMSampleBuffer</code> 的引用，会出现在回调函数中，如无特殊需求，传入 <code>NULL</code> 即可</li><li>infoFlagsOut 回调中输出的 Flags，如不需要，传入 0 即可。</li></ul></li></ul><h2 id=三h264-数据格式>三、H264 数据格式</h2><p>传输 H264 数据，主要是以 NALU 的格式传输（或者说 NALU 封装了 H264 数据），每次传输一个或者多个。</p><p><img src=https://gitee.com/SourceKim/PictureBed/raw/master/img/20200622004516.png alt></p><p>上面也说了：</p><blockquote><p>NALU (Network Abstraction Layer Unit) | H264 传输单元，一个单元内可能包含参数信息（SPS / PPS / SEI），或者帧片段（I-Slice / P-Slice / B-Slice)</p></blockquote><p>其中先收到的是参数信息（SPS / PPS / SEI），然后再收到帧片段（I-Slice / P-Slice / B-Slice)，这样代表 <strong>这些参数信息是描述接下来收到的片段的</strong>，知道收到下一组参数信息为止。</p><p><img src=https://gitee.com/SourceKim/PictureBed/raw/master/img/20200622004953.png alt></p><p>在 iOS 中，参数信息会被组装成 <code>CMFormatDescriptionRef</code> 对象，用于描述解码器。</p><p>了解了整体结构之后，让我们了解一下每个 NALU 的数据结构是怎么样的：</p><p><img src=https://gitee.com/SourceKim/PictureBed/raw/master/img/20200622005322.png alt></p><p>每个 NALU 开头都会有 <strong>3 个字节或者 4 个字节</strong> 的起始码，3 位是 001，4 位是 0001，然后才到正式的数据，用以分割每段 NALU 数据。</p><ul><li><p>在编码之后，我们会获得 <code>CMBlockBufferRef</code> 对象，然后需要将其 <strong>二进制数据</strong> 提取出来，进行网络传输，此时组装成的 NALU 数据，要注意插入起始码。</p></li><li><p>在收到编码的数据之后，要注意解码的时候也需要包含起始码。如果是整段 H264 数据，也可以使用起始码（001 / 0001）去做分割，读取出每段 NALU 数据，再组成包含 <code>CMBlockBufferRef</code> 的 <code>CMSampleBuffer</code> 进行解码。</p></li></ul><div class=blog-tags><a href=https://www.uiimage.com//tags/ios/>iOS</a>&nbsp;
<a href=https://www.uiimage.com//tags/%E9%9F%B3%E8%A7%86%E9%A2%91/>音视频</a>&nbsp;
<a href=https://www.uiimage.com//tags/videotoolbox/>VideoToolbox</a>&nbsp;</div><hr><section id=social-share><div class="list-inline footer-links"><div class=share-box aria-hidden=true><ul class=share><li><a href="//twitter.com/share?url=https%3a%2f%2fwww.uiimage.com%2fpost%2fblog%2fvideotoolbox%2fios-videotoolbox-codec-1%2f&text=iOS%20%e7%a1%ac%e7%bc%96%e7%a0%81%e7%a1%ac%e8%a7%a3%e7%a0%81%201%20-%20%e4%bb%8b%e7%bb%8d&via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter"></i></a></li><li><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.uiimage.com%2fpost%2fblog%2fvideotoolbox%2fios-videotoolbox-codec-1%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook"></i></a></li><li><a href="//reddit.com/submit?url=https%3a%2f%2fwww.uiimage.com%2fpost%2fblog%2fvideotoolbox%2fios-videotoolbox-codec-1%2f&title=iOS%20%e7%a1%ac%e7%bc%96%e7%a0%81%e7%a1%ac%e8%a7%a3%e7%a0%81%201%20-%20%e4%bb%8b%e7%bb%8d" target=_blank title="Share on Reddit"><i class="fab fa-reddit"></i></a></li><li><a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fwww.uiimage.com%2fpost%2fblog%2fvideotoolbox%2fios-videotoolbox-codec-1%2f&title=iOS%20%e7%a1%ac%e7%bc%96%e7%a0%81%e7%a1%ac%e8%a7%a3%e7%a0%81%201%20-%20%e4%bb%8b%e7%bb%8d" target=_blank title="Share on LinkedIn"><i class="fab fa-linkedin"></i></a></li><li><a href="//www.stumbleupon.com/submit?url=https%3a%2f%2fwww.uiimage.com%2fpost%2fblog%2fvideotoolbox%2fios-videotoolbox-codec-1%2f&title=iOS%20%e7%a1%ac%e7%bc%96%e7%a0%81%e7%a1%ac%e8%a7%a3%e7%a0%81%201%20-%20%e4%bb%8b%e7%bb%8d" target=_blank title="Share on StumbleUpon"><i class="fab fa-stumbleupon"></i></a></li><li><a href="//www.pinterest.com/pin/create/button/?url=https%3a%2f%2fwww.uiimage.com%2fpost%2fblog%2fvideotoolbox%2fios-videotoolbox-codec-1%2f&description=iOS%20%e7%a1%ac%e7%bc%96%e7%a0%81%e7%a1%ac%e8%a7%a3%e7%a0%81%201%20-%20%e4%bb%8b%e7%bb%8d" target=_blank title="Share on Pinterest"><i class="fab fa-pinterest"></i></a></li></ul></div></div></section><h4 class=see-also>也可以看看</h4><ul><li><a href=/post/blog/ios/ios-oop/>iOS 面向对象编程</a></li><li><a href=/post/blog/developing-normal-issues/attempt-to-set-a-non-property-list-object/>[User Defaults] Attempt to set a non-property-list object 崩溃</a></li><li><a href=/post/blog/audio-and-video/cgbitmapinfo-deep-analysis/>CGBitmapInfo / CGImageAlphaInfo / CGImageByteOrderInfo 详解</a></li><li><a href=/post/blog/metal/metal-12-blending/>Metal - 12 混合（Alpha Blending）</a></li><li><a href=/post/blog/metal/metal-11-generic-purpose-computing/>Metal - 11 GPGPU 通用计算（Compute Shader）</a></li></ul></article><ul class="pager blog-pager"><li class=previous><a href=https://www.uiimage.com/post/blog/ios/weak/ data-toggle=tooltip data-placement=top title="iOS 中 weak 详细介绍">&larr; 前一篇</a></li><li class=next><a href=https://www.uiimage.com/post/blog/network/http-congestion-strategy/ data-toggle=tooltip data-placement=top title="TCP 的拥塞控制 （滑动窗口协议）">后一篇 &rarr;</a></li></ul><span id=/post/blog/videotoolbox/ios-videotoolbox-codec-1/ class=leancloud_visitors data-flag-title="iOS 硬编码硬解码 1 - 介绍"><p></p></span><div id=vcomments></div><script src=//cdn1.lncld.net/static/js/3.0.4/av-min.js></script><script src=//unpkg.com/valine/dist/Valine.min.js></script><script type=text/javascript>new Valine({el:'#vcomments',appId:'Ld2PPgvVUNucDd8KP4B0kNNB-gzGzoHsz',appKey:'rijpKLUzykFXX0DGsbzHezk5',notify:false,verify:false,avatar:'robohash',placeholder:'有不当之处，求大佬指正~',visitor:false});</script></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:18666269733@163.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/SourceKim title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted"><a href=https://uiimage.com>Kim</a>
&nbsp;&bull;&nbsp;&copy;
2020
&nbsp;&bull;&nbsp;
<a href=https://www.uiimage.com/>Kim's Blog</a></p><p class="credits theme-by text-muted">由 <a href=https://gohugo.io>Hugo v0.69.2</a> 强力驱动 &nbsp;&bull;&nbsp; 主题 <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> 移植自 <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe crossorigin=anonymous></script><script src=https://code.jquery.com/jquery-1.12.4.min.js integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=https://www.uiimage.com/js/main.js></script><script>renderMathInElement(document.body);</script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js integrity=sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js integrity=sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q crossorigin=anonymous></script><script src=https://www.uiimage.com/js/load-photoswipe.js></script></body></html>