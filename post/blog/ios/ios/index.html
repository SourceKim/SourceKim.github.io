<!doctype html><html lang=zh itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>iOS 杂记 - Kim's Blog</title><meta name=description content="记录 iOS 常用知识点"><meta name=author content="Kim"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Kim\x27s Blog","url":"https:\/\/www.uiimage.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/www.uiimage.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/www.uiimage.com\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/www.uiimage.com\/post\/blog\/ios\/ios\/","name":"I o s 杂记"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Kim"},"headline":"iOS 杂记","description":"记录 iOS 常用知识点\n","inLanguage":"zh","wordCount":1558,"datePublished":"2018-05-02T03:32:24","dateModified":"2018-05-02T03:32:24","image":"https:\/\/www.uiimage.com\/img\/avatar.JPG","keywords":["iOS"],"mainEntityOfPage":"https:\/\/www.uiimage.com\/post\/blog\/ios\/ios\/","publisher":{"@type":"Organization","name":"https:\/\/www.uiimage.com\/","logo":{"@type":"ImageObject","url":"https:\/\/www.uiimage.com\/img\/avatar.JPG","height":60,"width":60}}}</script><meta property="og:title" content="iOS 杂记"><meta property="og:description" content="记录 iOS 常用知识点"><meta property="og:image" content="https://www.uiimage.com/img/avatar.JPG"><meta property="og:url" content="https://www.uiimage.com/post/blog/ios/ios/"><meta property="og:type" content="website"><meta property="og:site_name" content="Kim's Blog"><meta name=twitter:title content="iOS 杂记"><meta name=twitter:description content="记录 iOS 常用知识点"><meta name=twitter:image content="https://www.uiimage.com/img/avatar.JPG"><meta name=twitter:card content="summary"><link href=https://www.uiimage.com/img/avatar.JPG rel=icon type=image/x-icon><meta name=generator content="Hugo 0.69.2"><link rel=alternate href=https://www.uiimage.com/index.xml type=application/rss+xml title="Kim's Blog"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://www.uiimage.com/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://www.uiimage.com/css/syntax.css><link rel=stylesheet href=https://www.uiimage.com/css/codeblock.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css integrity=sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css integrity=sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>切换导航</span>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button>
<a class=navbar-brand href=https://www.uiimage.com/>Kim's Blog</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Home href=/>Home</a></li><li><a title=Tags href=/tags>Tags</a></li><li><a title=About href=/page/about/>About</a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Kim's Blog" href=https://www.uiimage.com/><img class=avatar-img src=https://www.uiimage.com/img/avatar.JPG alt="Kim's Blog"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>iOS 杂记</h1><span class=post-meta><i class="fas fa-calendar"></i>&nbsp;发表于 May 2, 2018
&nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;8&nbsp;分钟
&nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;1558&nbsp;个字
&nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;Kim</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><aside class=toc-article><nav id=TableOfContents><ul><li><a href=#1-除了-nsobject-之外还有什么基类>1. 除了 NSObject 之外，还有什么基类？</a></li><li><a href=#2-nsproxy-是什么>2. NSProxy 是什么？</a></li><li><a href=#3-instancetype--id-区别>3. <code>instancetype</code> & <code>id</code> 区别：</a></li><li><a href=#4-uibutton-不响应的原因>4. <code>UIButton</code> 不响应的原因：</a></li><li><a href=#5-ios-的-error-为什么是--双指针>5. iOS 的 error 为什么是 <code>**</code> 双指针？</a></li><li><a href=#6-死锁的产生原因>6. 死锁的产生原因？</a></li><li><a href=#7-为什么主线程同步会死锁>7. 为什么主线程同步会死锁</a></li><li><a href=#8-串行队列和并发队列>8. 串行队列和并发队列？</a></li><li><a href=#9-同步和异步>9. 同步和异步？</a></li><li><a href=#10-ios-进程和线程的区别>10. iOS 进程和线程的区别</a></li><li><a href=#11-id-和-nsobject-的区别>11. <code>id</code> 和 <code>NSObject</code> 的区别</a></li><li><a href=#12-atomic-一定线程安全>12. <code>atomic</code> 一定线程安全？</a></li><li><a href=#13-load--initialize>13. <code>+load</code> & <code>+initialize</code></a><ul><li><a href=#调用时机>调用时机</a></li><li><a href=#调用顺序>调用顺序</a></li><li><a href=#应用场景>应用场景</a></li></ul></li><li><a href=#14-使用-copy-修饰-nsstring不用-strong>14. 使用 <code>copy</code> 修饰 <code>NSString</code>，不用 <code>strong</code>？</a><ul><li><a href=#使用-strong-修饰-nsstring-会发生什么>①、使用 <code>strong</code> 修饰 <code>NSString</code> 会发生什么？</a></li><li><a href=#使用-copy-修饰-nsmutablearray-会发生什么>②、使用 <code>copy</code> 修饰 <code>NSMutableArray</code> 会发生什么？</a></li></ul></li><li><a href=#15-对-可变--不可变-对象调用-copy--mutablecopy-会发生什么>15. 对 可变 & 不可变 对象调用 <code>copy</code> & <code>mutableCopy</code> 会发生什么？</a></li><li><a href=#16-为什么-iboutlet-修饰的-uiview-也适用-weak-关键字>16. 为什么 <code>IBOutlet</code> 修饰的 <code>UIView</code> 也适用 <code>weak</code> 关键字？</a></li><li><a href=#17-nscache--nsdictionary>17. <code>NSCache</code> & <code>NSDictionary</code></a></li><li><a href=#18-designated-initializer>18. <code>Designated Initializer</code></a></li><li><a href=#19-现在-xcode-有自动合成属性实例变量了-autosynthesize什么时候还需要-synthesize>19. 现在 <code>XCode</code> 有自动合成属性实例变量了 （<code>AutoSynthesize</code>），什么时候还需要 <code>@synthesize</code>？</a></li><li><a href=#20-objc_msgsend-过程>20. <code>objc_msgSend</code> 过程？</a><ul><li><a href=#动态方法解析--消息转发><code>动态方法解析</code> & <code>消息转发</code>：</a></li></ul></li><li><a href=#21-nsoperation--gcd>21. NSOperation & GCD</a></li><li><a href=#22-信号量>22. 信号量</a></li><li><a href=#23-能否向编译后得到的类中增加实例变量能否向运行时创建的类中添加实例变量为什么>23. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</a></li><li><a href=#24-objc_msgforwawrd-是做什么的直接调用的后果>24. <code>objc_msgForwawrd</code> 是做什么的？直接调用的后果？</a><ul><li><a href=#25-下面代码会发生什么问题>25. 下面代码会发生什么问题？</a></li></ul></li><li><a href=#26-uiimage-imagenamed-生成的对象释放时机>26. <code>[UIImage imageNamed:]</code> 生成的对象释放时机</a></li><li><a href=#27-为什么-oc-中会有-metaclass>27. 为什么 OC 中会有 <code>metaclass</code></a></li><li><a href=#28-performselector-withobject-afterdelay>28. <code>performSelector: withObject: afterDelay:</code></a></li><li><a href=#29-查找两个视图的公共父视图>29. 查找两个视图的公共父视图</a></li><li><a href=#30-ios-线程之间是如何通信的>30. iOS 线程之间是如何通信的？</a></li><li><a href=#31-volatile-关键字>31 <code>volatile</code> 关键字</a></li></ul></nav></aside><article role=main class=blog-post><p>记录 iOS 常用知识点</p><h2 id=1-除了-nsobject-之外还有什么基类>1. 除了 NSObject 之外，还有什么基类？</h2><p>NSProxy</p><hr><h2 id=2-nsproxy-是什么>2. NSProxy 是什么？</h2><ul><li><p><code>NSProxy</code> 是和 <code>NSObject</code> 同级的一个类，可以说它是一个虚拟类，它只是实现了 <code>&lt;NSObject> </code>的协议</p></li><li><p>有两个方法，用于 <strong>消息转发</strong></p></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Objective-C data-lang=Objective-C>- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>forwardInvocation:</span>(NSInvocation <span style=color:#f92672>*</span>)anInvocation;

- (NSMethodSignature <span style=color:#f92672>*</span>)<span style=color:#a6e22e>methodSignatureForSelector:</span>(<span style=color:#66d9ef>SEL</span>)sel;
</code></pre></div><ul><li><code>NSProxy</code> 没有 <code>init:</code> 的方法，因此我们只能这样获取它的实例：</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Objective-C data-lang=Objective-C>MyProxy <span style=color:#f92672>*</span>proxy <span style=color:#f92672>=</span> [MyProxy alloc];
</code></pre></div><ul><li><p>应用： <strong>防止 NSTimer 循环引用</strong>：</p><ul><li><ol><li>创建一个 <code>WeakProxy</code> 来代理 timer 的持有对象 （注意这个 <code>target</code> 要用 <code>weak</code>）</li></ol></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>WeakProxy</span> : <span style=color:#a6e22e>NSProxy</span>
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>weak</span>,<span style=color:#66d9ef>nonatomic</span>,<span style=color:#66d9ef>readonly</span>)<span style=color:#66d9ef>id</span> target;
+ (<span style=color:#66d9ef>instancetype</span>)<span style=color:#a6e22e>proxyWithTarget:</span>(<span style=color:#66d9ef>id</span>)target;
- (<span style=color:#66d9ef>instancetype</span>)<span style=color:#a6e22e>initWithTarget:</span>(<span style=color:#66d9ef>id</span>)target;
<span style=color:#66d9ef>@end</span>

<span style=color:#66d9ef>@implementation</span> <span style=color:#a6e22e>WeakProxy</span>
- (<span style=color:#66d9ef>instancetype</span>)<span style=color:#a6e22e>initWithTarget:</span>(<span style=color:#66d9ef>id</span>)target{
    _target <span style=color:#f92672>=</span> target;
    <span style=color:#66d9ef>return</span> self;
}
+ (<span style=color:#66d9ef>instancetype</span>)<span style=color:#a6e22e>proxyWithTarget:</span>(<span style=color:#66d9ef>id</span>)target{
    <span style=color:#66d9ef>return</span> [[self alloc] initWithTarget:target];
}
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>forwardInvocation:</span>(NSInvocation <span style=color:#f92672>*</span>)invocation{
    <span style=color:#66d9ef>SEL</span> sel <span style=color:#f92672>=</span> [invocation selector];
    <span style=color:#66d9ef>if</span> ([self.target respondsToSelector:sel]) {
        [invocation invokeWithTarget:self.target];
    }
}
- (NSMethodSignature <span style=color:#f92672>*</span>)<span style=color:#a6e22e>methodSignatureForSelector:</span>(<span style=color:#66d9ef>SEL</span>)aSelector{
    <span style=color:#66d9ef>return</span> [self.target methodSignatureForSelector:aSelector];
}
- (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>respondsToSelector:</span>(<span style=color:#66d9ef>SEL</span>)aSelector{
    <span style=color:#66d9ef>return</span> [self.target respondsToSelector:aSelector];
}
<span style=color:#66d9ef>@end</span>
</code></pre></div><ul><li><ol start=2><li>将 timer 的 <code>target</code> 指向该 proxy</li></ol></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>self.timer <span style=color:#f92672>=</span> [NSTimer timerWithTimeInterval: <span style=color:#ae81ff>1</span>
                                     target:[WeakProxy proxyWithTarget:self]
                                   selector: <span style=color:#66d9ef>@selector</span>(timerInvoked:)
                                   userInfo: nil
                                    repeats: YES];
</code></pre></div></li></ul><hr><h2 id=3-instancetype--id-区别>3. <code>instancetype</code> & <code>id</code> 区别：</h2><ul><li><p>类型检查的区别：</p><ul><li><p>在 ARC 下： <code>instancetype</code> 用来在编译期确定实例的类型,而使用 <code>id</code> 的话, 编译器不检查类型, 运行时检查类型。</p></li><li><p>在 MRC 下： <code>instancetype</code> & <code>id</code> 都不做类型检查。</p></li></ul></li><li><p>用途区别</p><ul><li><p><code>id</code> 可以作为方法的参数类型，但 <code>instancetype</code> 不可以</p></li><li><p><code>instancetype</code> 只适用于初始化方法和便利构造器的返回值类型</p></li></ul><p>总结就是：<code>id</code> 可以作为函数的参数类型和任何的返回值类型；而 <code>instancetype</code> 只能是<strong>初始化方法和便利构造器的返回值类型</strong></p></li></ul><hr><h2 id=4-uibutton-不响应的原因>4. <code>UIButton</code> 不响应的原因：</h2><ul><li>它的父视图没有开启 用户交互</li><li>透明度为 0</li><li>收拾被覆盖在其上面的 子视图、或者同级视图 拦截了</li><li>点击地方的 point 超出了父视图的 frame</li></ul><hr><h2 id=5-ios-的-error-为什么是--双指针>5. iOS 的 error 为什么是 <code>**</code> 双指针？</h2><p>因为大多数的时候，iOS 会在<strong>内部实例化一个 <code>NSError</code> 的对象</strong>，因此我们需要传递一个指针进去，让其在内部指向该对象。</p><hr><h2 id=6-死锁的产生原因>6. 死锁的产生原因？</h2><ul><li><ol><li>竞争公共资源 （2 个以上的进程都在争夺<code>不可剥夺资源</code>）</li></ol></li><li><ol start=2><li>进程推进不当 （相互等待）</li></ol></li></ul><hr><h2 id=7-为什么主线程同步会死锁>7. 为什么主线程同步会死锁</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-OBJC data-lang=OBJC>dispatch_sync(dispatch_get_main_queue(), <span style=color:#f92672>^</span>(<span style=color:#66d9ef>void</span>){
    NSLog(<span style=color:#e6db74>@&#34;print&#34;</span>); <span style=color:#75715e>// 任务 1
</span><span style=color:#75715e></span>});
NSLog(<span style=color:#e6db74>@&#34;a&#34;</span>); <span style=color:#75715e>// 任务 2
</span></code></pre></div><p>永远不会打印 print 和 a，原因如下：</p><blockquote><p><a href=https://juejin.im/post/5b4d945ef265da0f9c6797f0>https://juejin.im/post/5b4d945ef265da0f9c6797f0</a></p></blockquote><hr><h2 id=8-串行队列和并发队列>8. 串行队列和并发队列？</h2><p>都是队列，具有 <code>FIFO</code> 的特性</p><p>串行队列：需要等待上一个任务执行完，下一个任务才会被执行，而且会根据 <code>FIFO</code> 去选定执行哪个</p><p>并发队列：多个任务可以同时执行，也是根据 <code>FIFO</code> 去选定执行哪个，但是无需等待上一个任务执行完，也可以执行下一个任务。</p><hr><h2 id=9-同步和异步>9. 同步和异步？</h2><p>是 GCD 的 同步和异步，针对任务的执行而言的，描述的是这个 任务 与上下文的关系。</p><p>同步：调用函数或者代码块的时候，必须要等待它执行完，才能执行下面的代码。</p><p>异步：不管调用的函数或者代码块有没有执行完，都会继续执行下面的代码。具备开启新线程的能力。</p><hr><h2 id=10-ios-进程和线程的区别>10. iOS 进程和线程的区别</h2><blockquote><p><a href=https://www.jianshu.com/p/ecb1a559f816>https://www.jianshu.com/p/ecb1a559f816</a></p></blockquote><hr><h2 id=11-id-和-nsobject-的区别>11. <code>id</code> 和 <code>NSObject</code> 的区别</h2><p>两个类型都含有 <code>Class isa</code>，但 <code>NSObject</code> 同时包含了一些其它的方法，并需要实现 <code>NSObject</code>协议。 所以 <code>NSObject</code> 可以用id来表示。但<code> id</code> 不能用 <code>NSObject</code> 来表示。</p><p><code>id</code> 就是一个指针，它可以指向的类型不仅限于 <code>NSObject</code>，实现了 <code>NSObject protocol</code> 即可。</p><p><code>NSObject*</code> 就是 <code>NSObject</code> 类型的指针了，它范围较小。</p><hr><h2 id=12-atomic-一定线程安全>12. <code>atomic</code> 一定线程安全？</h2><p>不是。</p><p>线程安全的概念是： <code>多条线程同时工作的情况下,通过运用线程锁,原子性等方法避免多条线程因为同时访问同一快内存造成的数据错误或冲突</code></p><p>而 <code>atomic</code> 只能是保证数据在存取（<code>getter & setter</code>) 是原子性的，并不能完全符合线程安全的概念。</p><p>比如 线程 a 先写，线程 b 释放了该属性，a 再去读这个属性的时候就会 crash。</p><hr><h2 id=13-load--initialize>13. <code>+load</code> & <code>+initialize</code></h2><p>都是线程安全的，内部都加了锁，因此不应再在内部使用锁防止造成死锁</p><h3 id=调用时机>调用时机</h3><p><code>+load</code> 加载类，发生在 dyld 链接的时候</p><p><code>+initialize</code> 初始化类，是懒加载，在类首次 <strong>接收第一条消息之前</strong> 会被调用</p><h3 id=调用顺序>调用顺序</h3><ul><li><p><code>+load</code></p><ul><li>父类和子类都有 <code>+load</code>，父类先调用，再到子类</li><li>子类没有实现 <code>+load</code>，不会调用父类的</li><li>先调用类的，再调用分类（<code>category</code>）的</li><li>多个 <code>category</code> 的调用顺序，是和 <code>Compile Source</code> 的调用顺序一致</li><li>类的 <code>+load</code> 调用顺序，是和 <code>Compile Source</code> 的调用顺序一致</li></ul><p>总结：</p><p>父类 -> 子类 -> 分类</p><p>子类没实现，也不会调用父类的</p><p>顺序和 <code>Compile Source</code> 的调用顺序一致</p></li><li><p><code>+initialize</code></p><ul><li>当子类未实现 <code>+initialize</code> 方法时，会自动调用父类的，</li><li>子类实现 <code>+initialize</code> 方法时,会覆盖父类的 （但是内部会先调用父类的 <code>+initialize</code>，不需要我们显式调用 <code>[super initialize]</code>）</li><li>当有多个 <code>category</code> 都实现了 <code>+initialize</code> 方法,会 <strong>覆盖</strong> 类中的方法,只执行一个（<code>Compile Sources</code> 最后一个 <code>category</code> 的）</li></ul><p>注意：</p><p>子类实现了之后，会自动先调用父类的，但是分类不会</p></li></ul><h3 id=应用场景>应用场景</h3><ul><li><p><code>+load</code> 一般用于 <strong>方法置换</strong></p></li><li><p><code>+initialize</code> 一般用于 <strong>初始化全局变量或静态变量</strong></p></li></ul><hr><h2 id=14-使用-copy-修饰-nsstring不用-strong>14. 使用 <code>copy</code> 修饰 <code>NSString</code>，不用 <code>strong</code>？</h2><p><code>strong</code> 修饰：只是将其引用计数 +1</p><p><code>copy</code> 修饰：会将属性拷贝一份, 内存地址和原来的值不一样</p><h3 id=使用-strong-修饰-nsstring-会发生什么>①、使用 <code>strong</code> 修饰 <code>NSString</code> 会发生什么？</h3><p>因为 iOS 多态的缘故，我们可以使用一个 <code>mutable</code> 指针指向一个 <code>immutable</code> 的属性，就会导致 <code>mutable</code> 被修改会让 <code>immutable</code> 的值也修改，因为两个指针指向的地址一样。</p><p>举个例子🌰：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Objective-C data-lang=Objective-C><span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>strong</span>) NSString <span style=color:#f92672>*</span> A; <span style=color:#75715e>// 不可变 A
</span><span style=color:#75715e></span>
NSMutableString <span style=color:#f92672>*</span> B <span style=color:#f92672>=</span> <span style=color:#e6db74>@&#34;BBB&#34;</span>; <span style=color:#75715e>// 可变 B
</span><span style=color:#75715e></span>

A <span style=color:#f92672>=</span> B;

B <span style=color:#f92672>=</span> <span style=color:#e6db74>@&#34;CCC&#34;</span>;

NSLog(<span style=color:#e6db74>@&#34;%@&#34;</span>, A);
</code></pre></div><p>此时会发现输出 <code>B</code> 修改后的值 <code>CCC</code>, 因为 <strong>A 和 B 指向的地址相同</strong></p><p>若使用 <code>copy</code> 修饰 <code>A</code>，则还是输出 <code>BBB</code>，因为 <strong>A 和 B 指向的地址不一样</strong></p><h3 id=使用-copy-修饰-nsmutablearray-会发生什么>②、使用 <code>copy</code> 修饰 <code>NSMutableArray</code> 会发生什么？</h3><p>在调用其 可变相关的函数（如 <code>append:</code>） 会崩溃，崩溃原因是 <code>unrecognized selector</code>。</p><p>因为由 15. 对 可变 & 不可变 对象调用 <code>copy</code> & <code>mutableCopy</code> 会发生什么？ 第二个结论可以得知：调用了 <code>copy</code> 会返回一个 <strong>不可变对象，即 <code>NSArray</code></strong>，他是没有 <code>append:</code> 方法的。</p><hr><h2 id=15-对-可变--不可变-对象调用-copy--mutablecopy-会发生什么>15. 对 可变 & 不可变 对象调用 <code>copy</code> & <code>mutableCopy</code> 会发生什么？</h2><ul><li><p>① 拷贝类型不同：</p><ul><li><p>深拷贝：对 <code>内容</code> 进行了拷贝</p></li><li><p>浅拷贝：对 <code>指针</code> 进行了拷贝</p></li></ul><table><thead><tr><th align=center>&mdash;</th><th align=center>copy</th><th align=center>mutableCopy</th></tr></thead><tbody><tr><td align=center>NS*</td><td align=center><code>浅</code></td><td align=center>深</td></tr><tr><td align=center>NSMutable*</td><td align=center>深</td><td align=center>深</td></tr></tbody></table></li><li><p>② 返回对象类型不同：</p><ul><li><p><code>NS* / NSMutalble* + copy = NS*</code></p></li><li><p><code>NS* / NSMutalble* + mutableCopy = NSMutalble*</code></p></li></ul></li></ul><p>总而言之有两个不一样：</p><p>① 仅有对 不可变 对象执行 <code>copy</code> 才是发生 浅拷贝，其他情况都是深拷贝</p><p>② 执行 <code>copy</code> 返回 <code>不可变对象</code> 类型，执行 <code>mutableCopy</code> 返回 <code>可变对象</code> 类型</p><hr><h2 id=16-为什么-iboutlet-修饰的-uiview-也适用-weak-关键字>16. 为什么 <code>IBOutlet</code> 修饰的 <code>UIView</code> 也适用 <code>weak</code> 关键字？</h2><p>在 <code>xib</code> 或者 <code>Sb</code> 拖控件时，其实控件就加载到了父控件的 <code>subviews</code> 数组里面，进行了 <strong>强引用</strong>，即使使用了 <code>weak</code>，也不造成对象的释放。</p><hr><h2 id=17-nscache--nsdictionary>17. <code>NSCache</code> & <code>NSDictionary</code></h2><p>两者都可以保存 <code>key-value</code>，但是有如下不同：</p><ul><li><p>① <code>NSCache</code> 会自动释放内存</p></li><li><p>② <code>NSCache</code> 是 <strong>线程安全</strong> 的，不同线程操作不会有问题</p></li><li><p>③ <code>NSCache</code> 不会对 <code>key</code> 进行 <code>copy</code>，而 <code>NSDictionary</code> 的 <code>key</code> 需要遵守 <code>&lt;NSCopying></code> 协议，会对其进行 <code>copy</code></p></li></ul><hr><h2 id=18-designated-initializer>18. <code>Designated Initializer</code></h2><p>用来修饰初始化方法，是指定构造器，其他便利构造器<strong>必须</strong>要调用它</p><p>这样可以保证某些必要的函数被调用或者属性被赋值</p><hr><h2 id=19-现在-xcode-有自动合成属性实例变量了-autosynthesize什么时候还需要-synthesize>19. 现在 <code>XCode</code> 有自动合成属性实例变量了 （<code>AutoSynthesize</code>），什么时候还需要 <code>@synthesize</code>？</h2><p>如下情况不会自动合成：</p><ul><li>同时重写了 <code>setter</code> 和 <code>getter</code> 时</li><li>重写了只读属性的 <code>getter</code> 时</li><li>使用了 <code>@dynamic</code> 时</li><li>在 <code>@protocol</code> 中定义的所有属性</li><li>在 <code>category</code> 中定义的所有属性</li><li><strong>重载的属性</strong></li></ul><hr><h2 id=20-objc_msgsend-过程>20. <code>objc_msgSend</code> 过程？</h2><ul><li>① 查看 <code>receiver</code> 指针是否为 0，是则返回</li><li>② 查看自身的 <code>方法缓存</code> 是否命中，命中则执行，然后返回，否则继续</li><li>③ 查看自己的 <code>方法列表</code> 是否存在，存在则执行，然后返回，否则继续</li><li>⑤ 查看父类 (<code>superclass</code> 指针) 的 <code>方法缓存</code> 是否命中，命中则执行，然后返回，否则继续</li><li>⑥ 查看父类的 <code>方法列表</code> 是否存在，存在则执行，然后返回，否则继续</li></ul><p>最后一只找到 <code>NSObject</code>，如果不存在，则进行 <code>动态方法解析</code> & <code>消息转发</code> 机制（此时会穿件一个 <code>IMP</code>对象（是一个函数指针） - <code>_objc_msgForward</code> 来做消息转发）</p><p>如果在 <code>消息转发</code> 的最后一步，即 <code>完整转发</code> 的 签名处都返回 <code>nil</code>，则会抛出异常：<code>unrecognized selector sent to instance</code></p><p>PS: 如果在 <code>方法列表</code> 存在，且不存在于 <code>缓存</code>，则加入 <code>缓存</code></p><h3 id=动态方法解析--消息转发><code>动态方法解析</code> & <code>消息转发</code>：</h3><p>以下是 <code>_objc_msgForward</code> 的调用</p><h4 id=a-动态方法解析>A. 动态方法解析</h4><p>让你有机会提供一个 <strong>新的函数</strong> 实现，添加了之后返回 <code>YES</code> 就不会进入下面消息转发的流程了</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-OBJC data-lang=OBJC><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>fooMethod</span>(<span style=color:#66d9ef>id</span> obj, <span style=color:#66d9ef>SEL</span> _cmd)  
{
    NSLog(<span style=color:#e6db74>@&#34;Doing foo&#34;</span>);
}

+ (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>resolveInstanceMethod:</span>(<span style=color:#66d9ef>SEL</span>)aSEL
{
    <span style=color:#66d9ef>if</span>(aSEL <span style=color:#f92672>==</span> <span style=color:#66d9ef>@selector</span>(foo:)){
        class_addMethod([self <span style=color:#66d9ef>class</span>], aSEL, (<span style=color:#66d9ef>IMP</span>)fooMethod, <span style=color:#e6db74>&#34;v@:&#34;</span>);
        <span style=color:#66d9ef>return</span> YES;
    }
    <span style=color:#66d9ef>return</span> [super resolveInstanceMethod];
}
</code></pre></div><h4 id=b-消息转发>B 消息转发</h4><ul><li><p>快速转发</p><p>此时我们可以提供一个 <strong>新的对象</strong> 去接收这个方法，返回该对象则不会执行下面的 <code>完整转发</code> 逻辑，返回 <code>nil</code> 或者 <code>self</code> 都会执行</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-OBJC data-lang=OBJC>- (<span style=color:#66d9ef>id</span>)<span style=color:#a6e22e>forwardingTargetForSelector:</span>(<span style=color:#66d9ef>SEL</span>)aSelector {
<span style=color:#66d9ef>if</span>(aSelector <span style=color:#f92672>==</span> <span style=color:#66d9ef>@selector</span>(foo:)){
    <span style=color:#66d9ef>return</span> [[BackupClass alloc] init];
}
<span style=color:#66d9ef>return</span> [super forwardingTargetForSelector:aSelector];
}
</code></pre></div></li><li><p>完整转发</p><p>提供 <code>-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code> 给开发者去做 <code>函数签名</code> 然后组装新的 <code>NSInvocation</code>，最后在 <code>-(void)forwardInvocation:(NSInvocation *)invocation</code> 调用该 <code>invocation</code>，完成完整转发。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-OBJC data-lang=OBJC>- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>forwardInvocation:</span>(NSInvocation <span style=color:#f92672>*</span>)invocation {
    <span style=color:#66d9ef>SEL</span> sel <span style=color:#f92672>=</span> invocation.selector;
    <span style=color:#66d9ef>if</span>([alternateObject respondsToSelector:sel]) {
        [invocation invokeWithTarget:alternateObject];
    } <span style=color:#66d9ef>else</span> {
        [self doesNotRecognizeSelector:sel];
    }
}

- (NSMethodSignature <span style=color:#f92672>*</span>)<span style=color:#a6e22e>methodSignatureForSelector:</span>(<span style=color:#66d9ef>SEL</span>)aSelector {
    NSMethodSignature <span style=color:#f92672>*</span>methodSignature <span style=color:#f92672>=</span> [super methodSignatureForSelector:aSelector];
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>methodSignature) {
        methodSignature <span style=color:#f92672>=</span> [NSMethodSignature signatureWithObjCTypes:<span style=color:#e6db74>&#34;v@:*&#34;</span>];
    }
    <span style=color:#66d9ef>return</span> methodSignature;
}
</code></pre></div><p>ps：我们可以在 <code>- (void)forwardInvocation:(NSInvocation *)invocation</code> 将 <code>invocation</code> 分发给对个对象去执行。</p></li></ul><hr><h2 id=21-nsoperation--gcd>21. NSOperation & GCD</h2><p>1，NSOperation拥有更多的函数可用，具体查看api。NSOperationQueue 是在GCD基础上实现的，只不过是GCD更高一层的抽象。</p><p>2，在NSOperationQueue中，可以建立各个NSOperation之间的依赖关系。</p><p>3，NSOperationQueue支持KVO。可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）</p><p>4，GCD 只支持FIFO 的队列，而NSOperationQueue可以调整队列的执行顺序（通过调整权重）。NSOperationQueue可以方便的管理并发、NSOperation之间的优先级。</p><h2 id=22-信号量>22. 信号量</h2><p>本质是通过 <code>互斥锁</code> 实现资源计数，保证资源的访问安全。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-OBJC data-lang=OBJC>dispatch_semaphore_create(<span style=color:#66d9ef>long</span> value); <span style=color:#75715e>// 创建一个semaphore　
</span><span style=color:#75715e></span>dispatch_semaphore_signal(dispatch_semaphore_t dsema); <span style=color:#75715e>// 发送一个信号
</span><span style=color:#75715e></span>dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout); <span style=color:#75715e>// 等到信号
</span></code></pre></div><p><code>dispatch_semaphore_wait</code> 当信号量 <code>小于 0</code> 的时候会一直等待直到超时。</p><hr><h2 id=23-能否向编译后得到的类中增加实例变量能否向运行时创建的类中添加实例变量为什么>23. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h2><ul><li><p>不能向编译后得到的类中增加实例变量</p></li><li><p>能向运行时创建的类中添加实例变量</p></li></ul><p>因为编译后的类已经注册在 <code>runtime</code> 中，类结构体中的 <code>objc_ivar_list</code> 实例变量的链表和 <code>instance_size</code> 实例变量的 <strong>内存大小已经确定</strong> ，同时runtime会调用 class_setIvarLayout 或 class_setWeakIvarLayout 来处理 <code>strong weak</code> 引用，所以不能向存在的类中添加实例变量</p><p>运行时创建的类是可以添加实例变量，调用 <code>class_addIvar</code>函数。但是得在调用<code>objc_allocateClassPair</code> 之后，<code>objc_registerClassPair</code> 之前，原因同上（在 分配、注册 之后，实例变量的 <strong>内存大小已经确定</strong>）</p><hr><h2 id=24-objc_msgforwawrd-是做什么的直接调用的后果>24. <code>objc_msgForwawrd</code> 是做什么的？直接调用的后果？</h2><p><code>_objc_msgForward</code> 是一个函数指针（和 <code>IMP</code> 的类型一样）用于消息转发；当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code> 会尝试做消息转发</p><p>在消息传递过程中，<code>objc_msgSend</code> 的动作比较清晰：首先在 <code>Class</code> 中的缓存查找 <code>IMP</code>（没有缓存则初始化缓存）如果没找到，则向父类的 <code>Class</code> 查找。如果一直查找到根类仍旧没有实现，则用 <code>_objc_msgForward</code> 函数指针代替 <code>IMP</code>，最后执行这个 <code>IMP</code></p><p>一旦调用了 <code>_objc_msgForward</code> ，将<strong>跳过查找 <code>IMP</code> 的过程，直接触发消息转发</strong>，如果调用了 <code>_objc_msgForward</code>，即使这个对象确实已经实现了这个方法，你也会告诉 <code>objc_msgSend</code>，我没有在这个对象里找到这个方法的实现，如果用不好会直接导致程序 <code>Crash</code></p><hr><h3 id=25-下面代码会发生什么问题>25. 下面代码会发生什么问题？</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-OBJC data-lang=OBJC><span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>, <span style=color:#66d9ef>strong</span>) NSString <span style=color:#f92672>*</span>str;

dispatch_queue_t queue <span style=color:#f92672>=</span> dispatch_queue_create(<span style=color:#e6db74>&#34;parallel&#34;</span>, DISPATCH_QUEUE_CONCURRENT);
<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1000000</span> ; i<span style=color:#f92672>++</span>) {
    dispatch_async(queue, <span style=color:#f92672>^</span>{
        self.str <span style=color:#f92672>=</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;changzifuchaung:%d&#34;</span>,i];
    });
}
</code></pre></div><p>会 <code>crash</code>，原因是：<strong>对象被销毁，但是指向它的指针依然存在（野指针），再次使用这个指针访问对象的时候就 crash 了 【EXC_BAD_ACCESS】</strong></p><p>解释：</p><p>在 ARC 的情况下，对使用 <code>strong</code> 修饰的 <code>str</code> 进行赋值，相当于 MRC 下执行如下代码</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-OBJC data-lang=OBJC>- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>setStr:</span>(NSString <span style=color:#f92672>*</span>)str{
    <span style=color:#66d9ef>if</span> (str <span style=color:#f92672>==</span> _str) <span style=color:#66d9ef>return</span>;
    <span style=color:#66d9ef>id</span> pre <span style=color:#f92672>=</span> _str;
    [str <span style=color:#66d9ef>retain</span>];<span style=color:#75715e>//1.先保留新值
</span><span style=color:#75715e></span>    _str <span style=color:#f92672>=</span> str;<span style=color:#75715e>//2.再进行赋值
</span><span style=color:#75715e></span>    [pre <span style=color:#66d9ef>release</span>];<span style=color:#75715e>//3.释放旧值
</span><span style=color:#75715e></span>}
</code></pre></div><p><code>DISPATCH_QUEUE_CONCURRENT</code> 是 并发队列，允许多个任务同时执行。</p><p>crash 的场景是，线程 A 执行到了 1，线程 B 执行到了 3，此时 A 的 <code>pre</code> 已经是 野指针 了，然后等线程 1 再执行到 3，就会因为使用 野指针 <code>pre</code> 导致 crash。</p><p>解决方法：</p><ul><li>1、使用串行队列</li></ul><p>将 <code>set</code> 方法改成在串行队列中执行就行，这样即使异步，但所有 <code>block</code> 操作追加在队列最后依次执行</p><ul><li>2、使用 <code>atomic</code></li></ul><p><code>atomic</code> 关键字相当于在 <code>setter</code> 方法加锁，这样每次执行 <code>setter</code> 都是线程安全的，但这只是单独针对 <code>setter</code> 方法而言的狭义的线程安全</p><ul><li>3、使用 <code>weak</code> 关键字</li></ul><p><code>weak</code> 的 <code>setter</code> 没有保留新值的操作，所以不会引发重复释放。当然这个时候要看具体情况能否使用 <code>weak</code>，可能值并不是所需要的值</p><p>4、使用互斥锁，保证数据访问的唯一性</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-OBJC data-lang=OBJC><span style=color:#66d9ef>@synchronized</span> (self) {
    self.str <span style=color:#f92672>=</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;changzifuchaung:%d&#34;</span>,i];
}
</code></pre></div><ul><li>5、使用 <code>Tagged Pointer</code></li></ul><p><code>Tagged Pointer</code> 是苹果在 64 位系统引入的内存技术。简单来说就是对于 <code>NSString(内存小于60位的字符串) 或 NSNumber(小于2^31)</code>，64 位的指针有 8 个字节，完全可以直接用这个空间来直接表示值，这样的话其实会将 <code>NSString</code> 和 <code>NSNumber</code> 对象由一个指针转换成一个值类型，而值类型的 <code>setter</code> 和 <code>getter</code> 又是原子的，从而线程安全</p><hr><h2 id=26-uiimage-imagenamed-生成的对象释放时机>26. <code>[UIImage imageNamed:]</code> 生成的对象释放时机</h2><p>使用 <code>imageNamed:</code> 这个方法生成的 <code>UIImage</code> 对象,会在应用的 <code>bundle</code> 中寻找图片,如果找到，则 <code>Cache</code> 到系统缓存中,作为内存的 <code>cache</code> ,而程序员是无法操作 <code>cache</code> 的,只能由系统自动处理</p><p>在循环中取获取 <code>UIImage</code>，最好加上一个 <code>@autoreleasepool</code> 这样就不会因为内存不断增大而发生 <code>memory warning</code></p><hr><h2 id=27-为什么-oc-中会有-metaclass>27. 为什么 OC 中会有 <code>metaclass</code></h2><p><code>MetaClass</code> 是用来存放着 <code>类方法</code> 的</p><p>根据 维基百科 的解释</p><pre><code>Metaclasses in Objective-C are almost the same as those in Smalltalk-80—not surprising since Objective-C borrows a lot from Smalltalk. Like Smalltalk, in Objective-C, the instance variables and methods are defined by an object's class. A class is an object, hence it is an instance of a metaclass.

(OC中的Metaclasses 基本上和Smalltalk-80相同,鉴于OC从Smalltalk中借鉴了很多因此这并不令人干到奇怪。类似Smalltalk 在OC中实例的变量和方法被定义在对象的类中,class也是一个对象,于是class是mataclass的一个实例。)

Like Smalltalk, in Objective-C, class methods are simply methods called on the class object, hence a class's class methods must be defined as instance methods in its metaclass. Because different classes can have different sets of class methods, each class must have its own separate metaclass. Classes and metaclasses are always created as a pair: the runtime has functions objc_allocateClassPair() and objc_registerClassPair() to create and register class-metaclass pairs, respectively.

(类似Smalltalk,在OC中类方法通过类对象调用,于是一个类的类方法必须在metaclass中以实例方法的形式定义。因为不同的类可以后不同的类方法集合，每一个类必须有自己独立的metaClass。Class和class-metaClass一起被创建和注册)

There are no names for the metaclasses; however, a pointer to any class object can be referred to with the generic type Class (similar to the type id being used for a pointer to any object). 

(metaClass没有名字,然而,指向任何类对象的指针可以用泛型类型引用)（类似id可以指向所有的对象）

Because class methods are inherited through inheritance, like Smalltalk, metaclasses must follow an inheritance scheme paralleling that of classes (e.g. if class A's parent class is class B, then A's metaclass's parent class is B's metaclass), except that of the root class.

(因为,类方法通过继承获取,类似Smalltalk,元类必须遵循与类类似的继承方案

Unlike Smalltalk, the metaclass of the root class inherits from the root class (usually NSObject using the Cocoa framework) itself. This ensures that all class objects are ultimately instances of the root class, so that you can use the instance methods of the root class, usually useful utility methods for objects, on class objects themselves.

(与Smalltalk不同,根类的metaclass继承自根类本身,这就确保了所有的类对象都是根类的对象。以便您可以使用根类的实例方法，通常是对象的有用实用工具方法，以及类对象本身。)

Since metaclass objects do not behave differently (you cannot add class methods for a metaclass, so metaclass objects all have the same methods), they are all instances of the same class—the metaclass of the root class (unlike Smalltalk). Thus, the metaclass of the root class is an instance of itself. The reason for this is that all metaclasses inherit from root class; hence, they must inherit the class methods of the root class.
</code></pre><hr><h2 id=28-performselector-withobject-afterdelay>28. <code>performSelector: withObject: afterDelay:</code></h2><p>该方法会开启一个 timer</p><p>如果是在子线程，则不会运行 （因为子线程默认不开启 Runloop）</p><p>所以我们要 <code>[[NSRunLoop current] run]</code> ，这个 timer 才会执行</p><p>在执行完这个任务之后，runloop 就会推出，所以不会阻塞下面的任务</p><hr><h2 id=29-查找两个视图的公共父视图>29. 查找两个视图的公共父视图</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-OBJC data-lang=OBJC>- (nullable UIView <span style=color:#f92672>*</span>)<span style=color:#a6e22e>findNearestCommonSuperView:</span> (UIView <span style=color:#f92672>*</span>)a <span style=color:#a6e22e>b:</span> (UIView <span style=color:#f92672>*</span>)b {
    
    <span style=color:#66d9ef>if</span> (a.superview <span style=color:#f92672>==</span> nil <span style=color:#f92672>||</span> b.superview <span style=color:#f92672>==</span> nil) <span style=color:#66d9ef>return</span> nil;
    
    NSMutableArray <span style=color:#f92672>*</span>sa <span style=color:#f92672>=</span> [NSMutableArray array];
    NSMutableArray <span style=color:#f92672>*</span>sb <span style=color:#f92672>=</span> [NSMutableArray array];
    
    <span style=color:#66d9ef>for</span> (UIView <span style=color:#f92672>*</span>v <span style=color:#f92672>=</span> a.superview; v; v<span style=color:#f92672>=</span>v.superview) {
        [sa addObject: v];
    }
    
    <span style=color:#66d9ef>for</span> (UIView <span style=color:#f92672>*</span>v <span style=color:#f92672>=</span> b.superview; v; v<span style=color:#f92672>=</span>v.superview) {
        [sb addObject: v];
    }
    
    NSUInteger lenA <span style=color:#f92672>=</span> sa.count;
    NSUInteger lenB <span style=color:#f92672>=</span> sb.count;
    NSUInteger len <span style=color:#f92672>=</span> MIN(lenA, lenB);
    
    UIView <span style=color:#f92672>*</span>same <span style=color:#f92672>=</span> nil;
    <span style=color:#66d9ef>for</span> (NSInteger i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> len; i<span style=color:#f92672>++</span>) {
        <span style=color:#66d9ef>if</span> (sa[lenA <span style=color:#f92672>-</span> i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>!=</span> sb[lenB <span style=color:#f92672>-</span> i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]) <span style=color:#66d9ef>return</span> same;
        same <span style=color:#f92672>=</span> sa[lenA <span style=color:#f92672>-</span> i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
    }
    
    <span style=color:#66d9ef>return</span> same;
}
</code></pre></div><h2 id=30-ios-线程之间是如何通信的>30. iOS 线程之间是如何通信的？</h2><ul><li><p><code>NSThread</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-OBJC data-lang=OBJC>
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>performSelectorOnMainThread:</span>(<span style=color:#66d9ef>SEL</span>)aSelector <span style=color:#a6e22e>withObject:</span>(nullable <span style=color:#66d9ef>id</span>)arg <span style=color:#a6e22e>waitUntilDone:</span>(<span style=color:#66d9ef>BOOL</span>)wait;

- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>performSelector:</span>(<span style=color:#66d9ef>SEL</span>)aSelector <span style=color:#a6e22e>onThread:</span>(NSThread <span style=color:#f92672>*</span>)thr <span style=color:#a6e22e>withObject:</span>(nullable <span style=color:#66d9ef>id</span>)arg <span style=color:#a6e22e>waitUntilDone:</span>(<span style=color:#66d9ef>BOOL</span>)wait API_AVAILABLE(macos(<span style=color:#ae81ff>10.5</span>), ios(<span style=color:#ae81ff>2.0</span>), watchos(<span style=color:#ae81ff>2.0</span>), tvos(<span style=color:#ae81ff>9.0</span>));
  
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>performSelectorInBackground:</span>(<span style=color:#66d9ef>SEL</span>)aSelector <span style=color:#a6e22e>withObject:</span>(nullable <span style=color:#66d9ef>id</span>)arg API_AVAILABLE(macos(<span style=color:#ae81ff>10.5</span>), ios(<span style=color:#ae81ff>2.0</span>), watchos(<span style=color:#ae81ff>2.0</span>), tvos(<span style=color:#ae81ff>9.0</span>));
</code></pre></div></li><li><p><code>GCD</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-OBJC data-lang=OBJC>
<span style=color:#75715e>//开启一个全局队列的子线程
</span><span style=color:#75715e></span>dispatch_async(dispatch_get_global_queue(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), <span style=color:#f92672>^</span>{
    <span style=color:#75715e>//1. 开始请求数据
</span><span style=color:#75715e></span>    <span style=color:#75715e>//...
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 2. 数据请求完毕
</span><span style=color:#75715e></span>    <span style=color:#75715e>//我们知道UI的更新必须在主线程操作，所以我们要从子线程回调到主线程
</span><span style=color:#75715e></span>    dispatch_async(dispatch_get_main_queue(), <span style=color:#f92672>^</span>{
        <span style=color:#75715e>//我已经回到主线程更新
</span><span style=color:#75715e></span>          
    });
});

<span style=color:#75715e>//线程延迟调用 通信
</span><span style=color:#75715e></span>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span style=color:#ae81ff>5.0</span> <span style=color:#f92672>*</span> NSEC_PER_SEC)), dispatch_get_main_queue(), <span style=color:#f92672>^</span>{
    NSLog(<span style=color:#e6db74>@&#34;## 在主线程延迟5秒调用 ##&#34;</span>);
});
</code></pre></div></li></ul><hr><h2 id=31-volatile-关键字>31 <code>volatile</code> 关键字</h2><p>修饰变量，代表这个变量随时有可能被改变，禁止编译器和优化器的优化</p><p>有的时候优化器会为了提高读取速度，会把变量存到寄存器中</p><p>使用该关键字，能让编译器每一次都去内存中重新读取这个值</p><div class=blog-tags><a href=https://www.uiimage.com//tags/ios/>iOS</a>&nbsp;</div><hr><section id=social-share><div class="list-inline footer-links"><div class=share-box aria-hidden=true><ul class=share><li><a href="//twitter.com/share?url=https%3a%2f%2fwww.uiimage.com%2fpost%2fblog%2fios%2fios%2f&text=iOS%20%e6%9d%82%e8%ae%b0&via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter"></i></a></li><li><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.uiimage.com%2fpost%2fblog%2fios%2fios%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook"></i></a></li><li><a href="//reddit.com/submit?url=https%3a%2f%2fwww.uiimage.com%2fpost%2fblog%2fios%2fios%2f&title=iOS%20%e6%9d%82%e8%ae%b0" target=_blank title="Share on Reddit"><i class="fab fa-reddit"></i></a></li><li><a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fwww.uiimage.com%2fpost%2fblog%2fios%2fios%2f&title=iOS%20%e6%9d%82%e8%ae%b0" target=_blank title="Share on LinkedIn"><i class="fab fa-linkedin"></i></a></li><li><a href="//www.stumbleupon.com/submit?url=https%3a%2f%2fwww.uiimage.com%2fpost%2fblog%2fios%2fios%2f&title=iOS%20%e6%9d%82%e8%ae%b0" target=_blank title="Share on StumbleUpon"><i class="fab fa-stumbleupon"></i></a></li><li><a href="//www.pinterest.com/pin/create/button/?url=https%3a%2f%2fwww.uiimage.com%2fpost%2fblog%2fios%2fios%2f&description=iOS%20%e6%9d%82%e8%ae%b0" target=_blank title="Share on Pinterest"><i class="fab fa-pinterest"></i></a></li></ul></div></div></section><h4 class=see-also>也可以看看</h4><ul><li><a href=/post/blog/opengl-es/opengl-es-13-%E6%B7%B7%E5%90%88blend/>OpenGL ES in iOS - OpenGL ES - 13 混合 blending</a></li><li><a href=/post/blog/opengl-es/opengl-es-12-%E5%AE%9E%E6%88%98%E6%B6%82%E9%B8%A6%E7%BB%98%E7%94%BB%E6%9D%BF/>OpenGL ES in iOS - OpenGL ES - 12 实战涂鸦绘画板</a></li><li><a href=/post/blog/opengl-es/opengl-es-11.-%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/>OpenGL ES in iOS - OpenGL ES - 11 渲染流程总结</a></li><li><a href=/post/blog/opengl-es/opengl-es-10-%E5%85%89%E7%85%A7/>OpenGL ES in iOS - OpenGL ES - 10 光照</a></li><li><a href=/post/blog/opengl-es/opengl-es-9-%E6%B8%B2%E6%9F%93%E6%91%84%E5%83%8F%E5%A4%B4%E9%87%87%E9%9B%86%E7%9A%84-yuv-%E6%95%B0%E6%8D%AE/>OpenGL ES in iOS - OpenGL ES - 9 渲染摄像头采集的 YUV 数据</a></li></ul></article><ul class="pager blog-pager"><li class=previous><a href=https://www.uiimage.com/post/blog/ios/lock/ data-toggle=tooltip data-placement=top title="iOS 中锁的探究">&larr; 前一篇</a></li><li class=next><a href=https://www.uiimage.com/post/blog/%E9%9F%B3%E8%A7%86%E9%A2%91/yuv/ data-toggle=tooltip data-placement=top title="iOS 中的 YUV 格式">后一篇 &rarr;</a></li></ul><span id=/post/blog/ios/ios/ class=leancloud_visitors data-flag-title="iOS 杂记"><p></p></span><div id=vcomments></div><script src=//cdn1.lncld.net/static/js/3.0.4/av-min.js></script><script src=//unpkg.com/valine/dist/Valine.min.js></script><script type=text/javascript>new Valine({el:'#vcomments',appId:'Ld2PPgvVUNucDd8KP4B0kNNB-gzGzoHsz',appKey:'rijpKLUzykFXX0DGsbzHezk5',notify:false,verify:false,avatar:'robohash',placeholder:'有不当之处，求大佬指正~',visitor:false});</script></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:18666269733@163.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/SourceKim title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted"><a href=https://uiimage.com>Kim</a>
&nbsp;&bull;&nbsp;&copy;
2020
&nbsp;&bull;&nbsp;
<a href=https://www.uiimage.com/>Kim's Blog</a></p><p class="credits theme-by text-muted">由 <a href=https://gohugo.io>Hugo v0.69.2</a> 强力驱动 &nbsp;&bull;&nbsp; 主题 <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> 移植自 <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe crossorigin=anonymous></script><script src=https://code.jquery.com/jquery-1.12.4.min.js integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=https://www.uiimage.com/js/main.js></script><script>renderMathInElement(document.body);</script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js integrity=sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js integrity=sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q crossorigin=anonymous></script><script src=https://www.uiimage.com/js/load-photoswipe.js></script></body></html>