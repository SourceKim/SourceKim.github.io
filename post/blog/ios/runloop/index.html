<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>iOS 中 Runloop 详细介绍 - Kim's Blog</title><meta name=description content="为了维持程序中任务的持续进行，iOS 中采用 Runloop 这种方式。"><meta name=author content="Kim"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Kim\x27s Blog","url":"https:\/\/uiimage.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/uiimage.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/uiimage.com\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/uiimage.com\/post\/blog\/ios\/runloop\/","name":"I o s 中 runloop 详细介绍"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Kim"},"headline":"iOS 中 Runloop 详细介绍","description":"为了维持程序中任务的持续进行，iOS 中采用 Runloop 这种方式。\n","inLanguage":"en","wordCount":539,"datePublished":"2019-01-04T23:00:00","dateModified":"2019-01-04T23:00:00","image":"https:\/\/uiimage.com\/img\/avatar.JPG","keywords":["iOS, iOS底层原理"],"mainEntityOfPage":"https:\/\/uiimage.com\/post\/blog\/ios\/runloop\/","publisher":{"@type":"Organization","name":"https:\/\/uiimage.com\/","logo":{"@type":"ImageObject","url":"https:\/\/uiimage.com\/img\/avatar.JPG","height":60,"width":60}}}</script><meta property="og:title" content="iOS 中 Runloop 详细介绍"><meta property="og:description" content="为了维持程序中任务的持续进行，iOS 中采用 Runloop 这种方式。"><meta property="og:image" content="https://uiimage.com/img/avatar.JPG"><meta property="og:url" content="https://uiimage.com/post/blog/ios/runloop/"><meta property="og:type" content="website"><meta property="og:site_name" content="Kim's Blog"><meta name=twitter:title content="iOS 中 Runloop 详细介绍"><meta name=twitter:description content="为了维持程序中任务的持续进行，iOS 中采用 Runloop 这种方式。"><meta name=twitter:image content="https://uiimage.com/img/avatar.JPG"><meta name=twitter:card content="summary"><link href=https://uiimage.com/img/avatar.JPG rel=icon type=image/x-icon><meta name=generator content="Hugo 0.69.2"><link rel=alternate href=https://uiimage.com/index.xml type=application/rss+xml title="Kim's Blog"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://uiimage.com/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://uiimage.com/css/syntax.css><link rel=stylesheet href=https://uiimage.com/css/codeblock.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css integrity=sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css integrity=sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R crossorigin=anonymous></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button>
<a class=navbar-brand href=https://uiimage.com/>Kim's Blog</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Home href=/>Home</a></li><li><a title=Tags href=/tags>Tags</a></li><li><a title=About href=/page/about/>About</a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Kim's Blog" href=https://uiimage.com/><img class=avatar-img src=https://uiimage.com/img/avatar.JPG alt="Kim's Blog"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>iOS 中 Runloop 详细介绍</h1><span class=post-meta><i class="fas fa-calendar"></i>&nbsp;Posted on January 4, 2019
&nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;3&nbsp;minutes
&nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;539&nbsp;words
&nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;Kim</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>为了维持程序中任务的持续进行，iOS 中采用 Runloop 这种方式。</p><h2 id=一runloop-介绍>一、Runloop 介绍</h2><ul><li><p>RunLoop 实际上是一个对象，这个对象在循环中用来处理程序运行过程中出现的各种事件（比如说触摸事件、UI刷新事件、定时器事件、Selector事件），从而保持程序的持续运行。</p></li><li><p>RunLoop 在没有事件处理的时候，会使线程进入睡眠模式，从而节省 CPU 资源，提高程序性能。</p></li><li><p>实际上 Runloop 是一个 <code>do-while</code> 循环。</p></li><li><p>在 Runloop 休眠的时候，进入了 <strong>内核态</strong>，唤醒时切换到了 <strong>用户态</strong>。</p></li><li><p>每个 Runloop 对应一个线程 <code>pThread</code>，他们是一一对应的关系，但是子线程的默认 Runloop 是不开启的</p></li><li><p>相关类：</p><ul><li>CFRunLoopRef：代表 RunLoop 的对象</li><li>CFRunLoopModeRef：代表 RunLoop 的运行模式</li><li>CFRunLoopSourceRef：就是 RunLoop 模型图中提到的输入源 / 事件源</li><li>CFRunLoopTimerRef：就是 RunLoop 模型图中提到的定时源</li><li>CFRunLoopObserverRef：观察者，能够监听 RunLoop 的状态改变</li></ul><p>关系如下：</p><p>一个 <code>runloop</code> 有 多个 <code>mode</code>，每个 mode 又对应不同的 <code>Sources</code> & <code>Timer</code> & <code>Observers</code>。</p><p><img src=https://gitee.com/SourceKim/PictureBed/raw/master/img/runnloop_mode.png alt=runnloop_mode></p><p>在 <code>Runloop</code> 定义的结构体中： <code>Sources</code> & <code>Timer</code> & <code>Observers</code> 被封装在了一个结构体的属性中，叫 <code>_commonModeItems</code></p></li></ul><h3 id=1-runloop-对象>1. Runloop 对象：</h3><ul><li><p>Core Foundation</p><ul><li><p>CFRunLoopGetCurrent(); // 获得当前线程的 RunLoop 对象</p></li><li><p>CFRunLoopGetMain(); // 获得主线程的 RunLoop 对象</p></li></ul></li><li><p>Foundation</p><ul><li><p>[NSRunLoop currentRunLoop]; // 获得当前线程的 RunLoop 对象</p></li><li><p>[NSRunLoop mainRunLoop]; // 获得主线程的 RunLoop 对象</p></li></ul></li></ul><h3 id=2-runloop-mode>2. Runloop mode:</h3><p>系统默认定义了多种运行模式（<code>CFRunLoopModeRef</code>），如下：</p><ul><li>kCFRunLoopDefaultMode：App的默认运行模式，通常主线程是在这个运行模式下运行</li><li>UITrackingRunLoopMode：跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）</li><li>UIInitializationRunLoopMode：在刚启动App时第进入的第一个 Mode，启动完成后就不再使用</li><li>GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到</li><li>kCFRunLoopCommonModes：伪模式，不是一种真正的运行模式（后边会用到）</li></ul><p>但是实际开放给我们的 mode：</p><ul><li>kCFRunLoopDefaultMode</li><li>UITrackingRunLoopMode</li><li>kCFRunLoopCommonModes</li></ul><p>此处要注意：</p><p><code>kCFRunLoopCommonModes</code> 并不是一个具体的 mode，而是 <code>kCFRunLoopDefaultMode</code> & <code>UITrackingRunLoopMode</code> 这两种 mode 的组合</p><h3 id=3-runloop-timer>3. Runloop Timer</h3><p>底层是 <code>CFTimer</code></p><p>是 Runloop 的计时器源，用以触发 <code>NSTimer</code> 的事件</p><p>NStimer 有如下的两个 api：</p><pre><code>timerWithTimeInterval: target: selector: userInfo: repeats:;

scheduledTimerWithTimeInterval: target: selector: userInfo: repeats:;
</code></pre><p>其中第一个是不加入到 Runloop 中，而第二个会 <strong>默认加入到 NSDefaultRunLoopMode 中</strong></p><p>当我们滑动 <code>UIScrollView</code> 的时候，会触发 <code>UITrackingRunLoopMode</code>，假如不将这个 Timer 加入到 <code>UITrackingRunLoopMode</code> 或者 <code>kCFRunLoopCommonModes</code>，将无法触发 Timer 的事件。</p><h3 id=4-runloop-source>4. Runloop Source</h3><p>分为：</p><ul><li><code>Source0</code> 非基于 port 的源</li><li><code>Source1</code> 基于Port，通过内核和其他线程通信，接收、分发系统事件</li></ul><p>类似于系统的 点击 等手势，是由 <code>Source0</code> 接收，然后分发到 <code>Source1</code> 去处理。</p><h3 id=5-runloop-observer>5. Runloop Observer</h3><p>Runloop 的观察者，观察 Runloop 的 <strong>状态变化</strong></p><p>Runloop 状态 （<code>CFRunLoopObserverRef</code>）有如下几种：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>CF_OPTIONS</span>(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1UL</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>0</span>),               <span style=color:#75715e>// 即将进入Loop：1
</span><span style=color:#75715e></span>    kCFRunLoopBeforeTimers <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1UL</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>),        <span style=color:#75715e>// 即将处理Timer：2    
</span><span style=color:#75715e></span>    kCFRunLoopBeforeSources <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1UL</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>2</span>),       <span style=color:#75715e>// 即将处理Source：4
</span><span style=color:#75715e></span>    kCFRunLoopBeforeWaiting <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1UL</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>5</span>),       <span style=color:#75715e>// 即将进入休眠：32
</span><span style=color:#75715e></span>    kCFRunLoopAfterWaiting <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1UL</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>6</span>),        <span style=color:#75715e>// 即将从休眠中唤醒：64
</span><span style=color:#75715e></span>    kCFRunLoopExit <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1UL</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>7</span>),                <span style=color:#75715e>// 即将从Loop中退出：128
</span><span style=color:#75715e></span>    kCFRunLoopAllActivities <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0FFFFFFFU</span>       <span style=color:#75715e>// 监听全部状态改变  
</span><span style=color:#75715e></span>};
</code></pre></div><p>添加 Observer 的方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>    <span style=color:#75715e>// 创建观察者
</span><span style=color:#75715e></span>    CFRunLoopObserverRef observer <span style=color:#f92672>=</span> CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>^</span>(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {
        NSLog(<span style=color:#e6db74>@&#34;监听到RunLoop发生改变---%zd&#34;</span>,activity);
    });

    <span style=color:#75715e>// 添加观察者到当前RunLoop中
</span><span style=color:#75715e></span>    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);

    <span style=color:#75715e>// 释放observer，最后添加完需要释放掉
</span><span style=color:#75715e></span>    CFRelease(observer);
</code></pre></div><p><img src=https://gitee.com/SourceKim/PictureBed/raw/master/img/runloop_detail.png alt=runloop_detail></p><p>在每次运行开启RunLoop的时候，所在线程的 <code>RunLoop</code> 会自动处理之前未处理的事件，并且通知相关的观察者。</p><p>具体的顺序如下：</p><ul><li>通知观察者RunLoop已经启动</li><li>通知观察者即将要开始的定时器</li><li>通知观察者任何即将启动的非基于端口的源</li><li>启动任何准备好的非基于端口的源</li><li>如果基于端口的源准备好并处于等待状态，立即启动；并进入步骤9</li><li>通知观察者线程进入休眠状态</li><li>将线程置于休眠知道任一下面的事件发生：<ul><li>某一事件到达基于端口的源</li><li>定时器启动</li><li>RunLoop 设置的时间已经超时</li><li>RunLoop 被显式唤醒</li></ul></li><li>通知观察者线程将被唤醒</li><li>处理未处理的事件<ul><li>如果用户定义的定时器启动，处理定时器事件并重启 RunLoop。进入步骤2</li><li>如果输入源启动，传递相应的消息</li><li>如果RunLoop被显示唤醒而且时间还没超时，重启 RunLoop。进入步骤2</li></ul></li><li>通知观察者RunLoop结束。</li></ul><h2 id=二-runloop--线程>二、 Runloop & 线程</h2><h3 id=0-子线程开启不会默认创建-runloop>0. 子线程开启不会默认创建 Runloop</h3><h3 id=1-mainrunloop-在-mainm-会默认开启>1. <code>MainRunloop</code> 在 <code>main.m</code> 会默认开启</h3><h3 id=2-线程和-runloop-之间是一一对应的runloop-是懒加载的使用时候才创建>2. 线程和 RunLoop 之间是一一对应的，Runloop 是懒加载的（使用时候才创建）</h3><p>其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。<strong>RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时</strong>。你只能在一个线程的内部获取其 RunLoop（主线程除外）</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=color:#75715e>/// 获取一个 pthread 对应的 RunLoop。
</span><span style=color:#75715e></span>CFRunLoopRef <span style=color:#a6e22e>_CFRunLoopGet</span>(pthread_t <span style=color:#66d9ef>thread</span>) {
    OSSpinLockLock(<span style=color:#f92672>&amp;</span>loopsLock);
    
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>loopsDic) {
        <span style=color:#75715e>// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。
</span><span style=color:#75715e></span>        loopsDic <span style=color:#f92672>=</span> CFDictionaryCreateMutable();
        CFRunLoopRef mainLoop <span style=color:#f92672>=</span> _CFRunLoopCreate();
        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);
    }

    <span style=color:#75715e>/// 直接从 Dictionary 里获取。
</span><span style=color:#75715e></span>    CFRunLoopRef loop <span style=color:#f92672>=</span> CFDictionaryGetValue(loopsDic, <span style=color:#66d9ef>thread</span>));
    
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>loop) {
        <span style=color:#75715e>/// 取不到时，创建一个
</span><span style=color:#75715e></span>        loop <span style=color:#f92672>=</span> _CFRunLoopCreate();
        CFDictionarySetValue(loopsDic, <span style=color:#66d9ef>thread</span>, loop);
        <span style=color:#75715e>/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。
</span><span style=color:#75715e></span>        _CFSetTSD(..., <span style=color:#66d9ef>thread</span>, loop, __CFFinalizeRunLoop);
    }
    
    OSSpinLockUnLock(<span style=color:#f92672>&amp;</span>loopsLock);
    <span style=color:#66d9ef>return</span> loop;
}

CFRunLoopRef <span style=color:#a6e22e>CFRunLoopGetMain</span>() {
    <span style=color:#66d9ef>return</span> _CFRunLoopGet(pthread_main_thread_np());
}

CFRunLoopRef <span style=color:#a6e22e>CFRunLoopGetCurrent</span>() {
    <span style=color:#66d9ef>return</span> _CFRunLoopGet(pthread_self());
}
</code></pre></div><h3 id=3-常驻线程>3. 常驻线程</h3><ul><li><p>why？</p><ul><li><p>通常有一些线程，是不必每次用都去创建的（会浪费时间），因此需要将该线程常驻等待着</p></li><li><p>因为子线程在创建之后默认是不加入到 Runloop 中的。当该线程的任务执行完毕之后，<strong>线程就被回收了</strong></p></li></ul></li><li><p>how？</p><ul><li><p>创建线程</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>_thread <span style=color:#f92672>=</span> [[NSThread alloc] initWithTarget:self selector:<span style=color:#66d9ef>@selector</span>(func:) object:nil];
</code></pre></div></li><li><p>线程执行的任务 （加入到 Runloop 中）</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>func:</span>(<span style=color:#66d9ef>id</span>)__unused object{
    <span style=color:#66d9ef>@autoreleasepool</span> {
        <span style=color:#75715e>//获取NSRunLoop对象，第一次获取不存在时系统会创建一个
</span><span style=color:#75715e></span>        NSRunLoop <span style=color:#f92672>*</span>runLoop <span style=color:#f92672>=</span> [NSRunLoop currentRunLoop];
        <span style=color:#75715e>/*
</span><span style=color:#75715e>        添加一个Source1事件的监听端口
</span><span style=color:#75715e>        RunLoop对象会一直监听这个端口，由于这个端口不会有任何事件到来所以不会产生影响
</span><span style=color:#75715e>        监听模式是默认模式，可以修改为Common
</span><span style=color:#75715e>        */</span>
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        <span style=color:#75715e>//启动RunLoop
</span><span style=color:#75715e></span>        [runLoop run];
    }
}
</code></pre></div><p>此处需要注意：要往这个 runloop 中加入一个 <code>port</code>，它才不会因为没有任务被回收。</p></li></ul></li></ul><h3 id=4-更新-ui>4. 更新 UI</h3><p>UI 的更新也是在 <code>Runloop (Main runloop)</code> 中</p><p>在 <strong>准备进入睡眠 & 即将退出 loop</strong> 两个时间点，会调用函数更新 UI 界面，此时会检查视图的标志位 flag 是否需要更新 (<code>- setNeedDisplay:</code> 可以主动设置该 flag)，然后一次过更新这个视图的 UI，这样可以提高效率。</p><p>所以我们说要在主线程更新 UI。</p><h3 id=5-runloop--autoreleasepool>5. Runloop & AutoReleasePool</h3><h4 id=51-主线程-autoreleasepool-的创建--销毁>5.1 主线程 autoreleasepool 的创建 & 销毁</h4><p>根据苹果官方文档中对 NSRunLoop 的描述，我们可以知道每一个线程，包括主线程，都会拥有一个专属的 NSRunLoop 对象，并且会在有需要的时候自动创建。</p><blockquote><p>Each NSThread object, including the application’s main thread, has an NSRunLoop object automatically created for it as needed.</p></blockquote><p><code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</code> 获取的也应该如此</p><p>App 启动后，苹果在主线程 RunLoop 里注册了<strong>两个 <code>Observer</code></strong>，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>。</p><ul><li><p>第一个 Observer 监视的事件是 <code>Entry(即将进入Loop)</code>，其回调内会调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。其 order 是 -2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p></li><li><p>第二个 Observer 监视了 <code>两个事件： BeforeWaiting(准备进入休眠) & Exit(即将退出Loop)</code>，这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后</p><ul><li><p><code>BeforeWaiting(准备进入休眠)</code> 时调用 <code>objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> <strong>释放旧的池并创建新池</strong></p></li><li><p><code>Exit(即将退出Loop)</code> 时调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。</p></li></ul></li></ul><div class=blog-tags><a href=https://uiimage.com//tags/ios/>iOS</a>&nbsp;
<a href=https://uiimage.com//tags/ios%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/>iOS底层原理</a>&nbsp;</div><hr><section id=social-share><div class="list-inline footer-links"><div class=share-box aria-hidden=true><ul class=share><li><a href="//twitter.com/share?url=https%3a%2f%2fuiimage.com%2fpost%2fblog%2fios%2frunloop%2f&text=iOS%20%e4%b8%ad%20Runloop%20%e8%af%a6%e7%bb%86%e4%bb%8b%e7%bb%8d&via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter"></i></a></li><li><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fuiimage.com%2fpost%2fblog%2fios%2frunloop%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook"></i></a></li><li><a href="//reddit.com/submit?url=https%3a%2f%2fuiimage.com%2fpost%2fblog%2fios%2frunloop%2f&title=iOS%20%e4%b8%ad%20Runloop%20%e8%af%a6%e7%bb%86%e4%bb%8b%e7%bb%8d" target=_blank title="Share on Reddit"><i class="fab fa-reddit"></i></a></li><li><a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fuiimage.com%2fpost%2fblog%2fios%2frunloop%2f&title=iOS%20%e4%b8%ad%20Runloop%20%e8%af%a6%e7%bb%86%e4%bb%8b%e7%bb%8d" target=_blank title="Share on LinkedIn"><i class="fab fa-linkedin"></i></a></li><li><a href="//www.stumbleupon.com/submit?url=https%3a%2f%2fuiimage.com%2fpost%2fblog%2fios%2frunloop%2f&title=iOS%20%e4%b8%ad%20Runloop%20%e8%af%a6%e7%bb%86%e4%bb%8b%e7%bb%8d" target=_blank title="Share on StumbleUpon"><i class="fab fa-stumbleupon"></i></a></li><li><a href="//www.pinterest.com/pin/create/button/?url=https%3a%2f%2fuiimage.com%2fpost%2fblog%2fios%2frunloop%2f&description=iOS%20%e4%b8%ad%20Runloop%20%e8%af%a6%e7%bb%86%e4%bb%8b%e7%bb%8d" target=_blank title="Share on Pinterest"><i class="fab fa-pinterest"></i></a></li></ul></div></div></section><h4 class=see-also>See also</h4><ul><li><a href=/post/blog/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/sdwebimage/>SDWebImage 笔记</a></li><li><a href=/post/blog/%E9%9F%B3%E8%A7%86%E9%A2%91/avfoundation/>AVFoundation - 1. 基础介绍</a></li><li><a href=/post/blog/ios/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/>编译 & 加载 原理</a></li><li><a href=/post/blog/ios/weak/>iOS 中 weak 详细介绍</a></li><li><a href=/post/blog/ios/hashisequal/>Hash isEqual == 的区别和联系</a></li></ul></article><ul class="pager blog-pager"><li class=previous><a href=https://uiimage.com/post/blog/network/http%E7%8A%B6%E6%80%81%E7%A0%81/ data-toggle=tooltip data-placement=top title="HTTP 常见状态码">&larr; Previous Post</a></li><li class=next><a href=https://uiimage.com/post/blog/ios/block/ data-toggle=tooltip data-placement=top title="Block 原理 & 本质">Next Post &rarr;</a></li></ul></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:18666269733@163.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/SourceKim title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted"><a href=https://uiimage.com>Kim</a>
&nbsp;&bull;&nbsp;&copy;
2019
&nbsp;&bull;&nbsp;
<a href=https://uiimage.com/>Kim's Blog</a></p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Hugo v0.69.2</a> powered &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe crossorigin=anonymous></script><script src=https://code.jquery.com/jquery-1.12.4.min.js integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=https://uiimage.com/js/main.js></script><script>renderMathInElement(document.body);</script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js integrity=sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js integrity=sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q crossorigin=anonymous></script><script src=https://uiimage.com/js/load-photoswipe.js></script></body></html>