<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kim's Blog</title><link>https://sourcekim.github.io/</link><description>Recent content on Kim's Blog</description><generator>Hugo -- gohugo.io</generator><language>ZH-CN</language><managingEditor>18666269733@163.com (Kim)</managingEditor><webMaster>18666269733@163.com (Kim)</webMaster><lastBuildDate>Thu, 21 Nov 2019 23:00:00 +0800</lastBuildDate><atom:link href="https://sourcekim.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>SDWebImage 笔记</title><link>https://sourcekim.github.io/post/blog/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/sdwebimage/</link><pubDate>Thu, 21 Nov 2019 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/sdwebimage/</guid><description>&lt;p>SDWebImage 是 iOS 常用的图片加载框架，支持对网络图片进行 内存 &amp;amp; 硬盘 缓存，并且能很方便地将图片应用到 UIImageView、UIButton 等控件上&lt;/p></description></item><item><title>AVFoundation - 1. 基础介绍</title><link>https://sourcekim.github.io/post/blog/%E9%9F%B3%E8%A7%86%E9%A2%91/avfoundation/</link><pubDate>Thu, 14 Nov 2019 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/%E9%9F%B3%E8%A7%86%E9%A2%91/avfoundation/</guid><description>&lt;p>AVFoundation 基础介绍，包括 &lt;code>CMTime&lt;/code> 的介绍和常用的一些类介绍&lt;/p></description></item><item><title>编译 &amp; 加载 原理</title><link>https://sourcekim.github.io/post/blog/ios/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</link><pubDate>Sat, 26 Oct 2019 14:20:35 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/ios/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</guid><description>&lt;p>我们所写的代码是一个 &lt;code>XCode&lt;/code> 的工程，在按下 &lt;code>command + r&lt;/code> 之时，会将其 &lt;code>编译&lt;/code> 成 &lt;code>MACH-O&lt;/code> 可执行文件；然后放到手机上，再点击应用的时候，系统的内核会开启一个进程，然后通过 &lt;code>dyld&lt;/code> 执行 &lt;code>加载&lt;/code> 流程。&lt;/p></description></item><item><title>OSI 七层模型</title><link>https://sourcekim.github.io/post/blog/network/osi/</link><pubDate>Fri, 11 Oct 2019 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/network/osi/</guid><description>&lt;p>应、表、会、传、网、链、物&lt;/p></description></item><item><title>HTTPS 详解</title><link>https://sourcekim.github.io/post/blog/network/https/</link><pubDate>Mon, 19 Aug 2019 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/network/https/</guid><description>&lt;p>HTTPS = HTTP + SSL/TLS 协议&lt;/p>
&lt;p>SSL 的全称是 &lt;code>Secure Sockets Layer&lt;/code>，即安全套接层协议，是为网络通信提供安全及数据完整性的一种安全协议。&lt;/p>
&lt;p>TLS 的全称是 &lt;code>Transport Layer Security&lt;/code>，即安全传输层协议。&lt;/p>
&lt;p>即 &lt;code>HTTPS&lt;/code> 是安全的 &lt;code>HTTP&lt;/code>。&lt;/p></description></item><item><title>TCP 的拥塞控制 （滑动窗口协议）</title><link>https://sourcekim.github.io/post/blog/network/http%E6%8B%A5%E5%A0%B5%E7%AD%96%E7%95%A5/</link><pubDate>Sun, 28 Jul 2019 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/network/http%E6%8B%A5%E5%A0%B5%E7%AD%96%E7%95%A5/</guid><description>&lt;ul>
&lt;li>
&lt;p>TCP 的拥塞控制：通过对发送端的 流量控制，即控制其报文发送速度，使之能匹配接收端的速度，达到防止网络性能下降的策略。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>滑动窗口协议：通过该协议来实现 TCP 的拥塞控制。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>iOS 中 weak 详细介绍</title><link>https://sourcekim.github.io/post/blog/ios/weak/</link><pubDate>Wed, 08 May 2019 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/ios/weak/</guid><description>&lt;p>&lt;code>Runtime&lt;/code> 为我们维护了一张&lt;strong>全局&lt;/strong>的 &lt;code>weak 表（弱引用表）&lt;/code>，是一张 &lt;code>哈希表&lt;/code>，该表的 &lt;code>key&lt;/code> 是要弱引用的对象的地址， &lt;code>value&lt;/code> 是所有指向该对象的 &lt;code>weak&lt;/code> 指针，是一个数组。&lt;/p></description></item><item><title>HTTP 三次握手 &amp; 四次挥手 详解</title><link>https://sourcekim.github.io/post/blog/network/http%E6%8F%A1%E6%89%8B/</link><pubDate>Tue, 23 Apr 2019 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/network/http%E6%8F%A1%E6%89%8B/</guid><description>&lt;p>HTTP 三次握手 &amp;amp; 四次挥手&lt;/p></description></item><item><title>HTTP2.0</title><link>https://sourcekim.github.io/post/blog/network/http2.0/</link><pubDate>Sat, 20 Apr 2019 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/network/http2.0/</guid><description>&lt;p>HTTP2.0&lt;/p></description></item><item><title>Hash isEqual == 的区别和联系</title><link>https://sourcekim.github.io/post/blog/ios/hashisequal/</link><pubDate>Fri, 12 Apr 2019 13:12:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/ios/hashisequal/</guid><description>&lt;p>在 OC 中：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>hash&lt;/code> 的类型是 &lt;code>NSUInteger&lt;/code>，可以初步用来判等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>isEqual&lt;/code> 是相等的绝对判定&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>==&lt;/code> 仅是对比变量地址的指针是否相等&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>DNS 介绍</title><link>https://sourcekim.github.io/post/blog/network/dns/</link><pubDate>Thu, 21 Mar 2019 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/network/dns/</guid><description>&lt;p>域名系统 &lt;code>（Domain Name System，DNS）&lt;/code>&lt;/p></description></item><item><title>iOS 中 Runtime 详细介绍</title><link>https://sourcekim.github.io/post/blog/ios/runtime/</link><pubDate>Mon, 04 Mar 2019 22:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/ios/runtime/</guid><description>&lt;p>Runtime，运行时的库，是一套使用 C 和汇编的 API，因为 runtime 使得 OC 可以成为一个动态语言。平时我们定义的对象，大多都是编译后就是 runtime 的 &lt;code>objc_class&lt;/code> 结构体；我们调用方法，编译之后会变成 &lt;code>objc_msgSend:&lt;/code>，也就是通过给对象发送消息来调用方法，方法实际的实现在运行时才能被确定。&lt;/p></description></item><item><title>Block 原理 &amp; 本质</title><link>https://sourcekim.github.io/post/blog/ios/block/</link><pubDate>Thu, 17 Jan 2019 18:20:35 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/ios/block/</guid><description>&lt;p>iOS 的 &lt;code>block&lt;/code> 本质上也是一个 OC 的对象，是一个拥有 &lt;code>isa&lt;/code> 指针的结构体，能够捕获外部变量的值、指针地址。&lt;/p></description></item><item><title>iOS 中 Runloop 详细介绍</title><link>https://sourcekim.github.io/post/blog/ios/runloop/</link><pubDate>Fri, 04 Jan 2019 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/ios/runloop/</guid><description>&lt;p>为了维持程序中任务的持续进行，iOS 中采用 Runloop 这种方式。&lt;/p></description></item><item><title>HTTP 常见状态码</title><link>https://sourcekim.github.io/post/blog/network/http%E7%8A%B6%E6%80%81%E7%A0%81/</link><pubDate>Fri, 09 Nov 2018 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/network/http%E7%8A%B6%E6%80%81%E7%A0%81/</guid><description>&lt;ul>
&lt;li>1xx 信息提示&lt;/li>
&lt;li>2xx 成功&lt;/li>
&lt;li>3xx 重定向&lt;/li>
&lt;li>4xx 客户端错误&lt;/li>
&lt;li>5xx 服务器错误&lt;/li>
&lt;/ul></description></item><item><title>算法 - 快速排序</title><link>https://sourcekim.github.io/post/blog/algorithm/quicksort/</link><pubDate>Sat, 21 Jul 2018 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/algorithm/quicksort/</guid><description>&lt;p>快速排序的时间复杂度是 &lt;code>O(nlogn)&lt;/code>，最坏情况是 &lt;code>O(n²)&lt;/code>，最坏的情况就出现在给定数组是倒序排列&lt;/p>
&lt;p>快速排序是不稳定排序，不稳定发生在 &lt;strong>&lt;code>pivot&lt;/code> 和 &lt;code>a[j]&lt;/code> 交换的时刻&lt;/strong>&lt;/p></description></item><item><title>算法 - 归并排序</title><link>https://sourcekim.github.io/post/blog/algorithm/mergesort/</link><pubDate>Fri, 20 Jul 2018 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/algorithm/mergesort/</guid><description>&lt;p>归并排序的时间复杂度是 &lt;code>O(nlogn)&lt;/code>，最坏情况也是 &lt;code>O(nlogn)&lt;/code>&lt;/p>
&lt;p>归并排序是 &lt;code>稳定&lt;/code> 排序， &lt;strong>因为大小相同不做交换&lt;/strong>&lt;/p></description></item><item><title>算法 - 堆排序</title><link>https://sourcekim.github.io/post/blog/algorithm/heapsort/</link><pubDate>Wed, 18 Jul 2018 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/algorithm/heapsort/</guid><description>&lt;p>堆排序的时间复杂度 最好最坏都是 &lt;code>O（nlogn）&lt;/code>，是 &lt;code>不稳定&lt;/code> 排序&lt;/p></description></item><item><title>YUV</title><link>https://sourcekim.github.io/post/blog/%E9%9F%B3%E8%A7%86%E9%A2%91/yuv/</link><pubDate>Wed, 20 Jun 2018 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/%E9%9F%B3%E8%A7%86%E9%A2%91/yuv/</guid><description>&lt;p>YUV 和 RGB 相比：Y 表示亮度，UV 分量表示色差，能更好地对颜色进行压缩。&lt;/p></description></item><item><title>iOS 杂记</title><link>https://sourcekim.github.io/post/blog/ios/ios/</link><pubDate>Wed, 02 May 2018 03:32:24 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/ios/ios/</guid><description>&lt;p>记录 iOS 常用知识点&lt;/p></description></item><item><title>iOS 中锁的探究</title><link>https://sourcekim.github.io/post/blog/ios/lock/</link><pubDate>Thu, 03 Aug 2017 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/ios/lock/</guid><description>&lt;p>iOS 中的锁分为：互斥锁、递归锁、条件锁、自旋锁等。&lt;/p></description></item><item><title>iOS 的 架构 &amp; 寄存器（register）</title><link>https://sourcekim.github.io/post/blog/ios/register/</link><pubDate>Thu, 03 Aug 2017 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/ios/register/</guid><description>&lt;p>包括所有架构的介绍和部分寄存器的作用。&lt;/p></description></item><item><title/><link>https://sourcekim.github.io/post/blog/ios/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/ios/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description>设计模式 单例模式 在 APP 的声明周期之内只被一个实例对象
实现 @implementation MySingleton static MySingleton *manager = nil; + (instancetype)shared { if (manager == nil) { static dispatch_once_t onceToken; dispatch_once(&amp;amp;onceToken, ^{ manager = [[MySingleton alloc] init]; }); } return manager; } + (instancetype)allocWithZone:(struct _NSZone *)zone { return [MySingleton shared]; } 这样调用 alloc 也是获得静态的单例对象
优点 跨模块
资源共享
缺点 工厂模式 通过定义工厂类，可以生成对象。
一般用来生成复杂对象。
优点： 高拓展性，新建一个方法即可拓展一个新的构造复杂实例的方法
去除了业务和对象细节的耦合</description></item><item><title>About me</title><link>https://sourcekim.github.io/page/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/page/about/</guid><description>多年 iOS 经验，专注音视频、图像编辑、CV 联系我: E-Mail: 18666269733@163.com</description></item><item><title>iOS 的 KVO &amp; KVC 本质</title><link>https://sourcekim.github.io/post/blog/ios/kvokvc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>18666269733@163.com (Kim)</author><guid>https://sourcekim.github.io/post/blog/ios/kvokvc/</guid><description>&lt;ul>
&lt;li>
&lt;p>KVO：监听属性的变化&lt;/p>
&lt;/li>
&lt;li>
&lt;p>KVC：属性（成员变量）设值&lt;/p>
&lt;/li>
&lt;/ul></description></item></channel></rss>