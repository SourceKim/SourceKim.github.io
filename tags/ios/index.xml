<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>iOS on Kim's Blog</title><link>https://www.uiimage.com/tags/ios/</link><description>Recent content in iOS on Kim's Blog</description><generator>Hugo -- gohugo.io</generator><language>ZH-CN</language><managingEditor>18666269733@163.com (Kim)</managingEditor><webMaster>18666269733@163.com (Kim)</webMaster><lastBuildDate>Mon, 18 May 2020 23:00:00 +0800</lastBuildDate><atom:link href="https://www.uiimage.com/tags/ios/index.xml" rel="self" type="application/rss+xml"/><item><title>OpenGL ES in iOS - 8. 渲染摄像头采集数据（CVOpenGLESTextureCacheRef）</title><link>https://www.uiimage.com/post/blog/opengl-es/opengl-es-8-%E6%B8%B2%E6%9F%93%E6%91%84%E5%83%8F%E5%A4%B4%E9%87%87%E9%9B%86%E7%9A%84%E6%95%B0%E6%8D%AE/</link><pubDate>Mon, 18 May 2020 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/opengl-es/opengl-es-8-%E6%B8%B2%E6%9F%93%E6%91%84%E5%83%8F%E5%A4%B4%E9%87%87%E9%9B%86%E7%9A%84%E6%95%B0%E6%8D%AE/</guid><description>&lt;p>本篇文章使用 AVFoundation 采集 &lt;code>kCVPixelFormatType_32BGRA&lt;/code> 数据，并且将采集到的 &lt;code>CMSampleBuffer&lt;/code> 使用 &lt;code>CVOpenGLESTextureCacheRef&lt;/code> 快速上传到 OpenGL ES 的 &lt;code>texutre&lt;/code>，然后将采集到的内容渲染到 &lt;code>EAGLLayer&lt;/code> 上。&lt;/p></description></item><item><title>OpenGL ES 获取 Uniform 的位置 glGetUniformLocation 返回 -1</title><link>https://www.uiimage.com/post/blog/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/glgetuniformlocation-%E8%BF%94%E5%9B%9E-1/</link><pubDate>Mon, 18 May 2020 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/glgetuniformlocation-%E8%BF%94%E5%9B%9E-1/</guid><description>uniform sampler2D lumaTexture; uniform sampler2D chromaTexture; uniform highp mat3 YUV_To_RGB_Matrix; uniform highp vec3 YUV_Translation; varying highp vec2 outTexCoor; void main() { highp vec3 yuv, rgb; yuv.r = texture2D(lumaTexture, outTexCoor).r; yuv.gb = texture2D(lumaTexture, outTexCoor).rg; rgb = YUV_To_RGB_Matrix * (yuv + YUV_Translation); gl_FragColor = vec4(rgb, 1.0); } 通过 glGetUniformLocation(_glProgram, &amp;quot;chromaTexture&amp;quot;); 返回一直是 -1
一番搜索才发现，原来是自己复制粘贴的笔误，将 chromaTexture 写成了 lumaTexture，即 chromaTexture 根本没有在 shader 中使用！
当该 uniform 没有被使用的时候，其 loction 就是 -1
另外：
没有被使用也包括，如果这个 uniform 没有对 gl_FragColor 产生影响，也认为 没有被使用。</description></item><item><title>OpenGL ES in iOS - 7 画一个立方体</title><link>https://www.uiimage.com/post/blog/opengl-es/opengl-es-7-%E7%94%BB%E4%B8%80%E4%B8%AA%E7%AB%8B%E6%96%B9%E4%BD%93/</link><pubDate>Sat, 16 May 2020 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/opengl-es/opengl-es-7-%E7%94%BB%E4%B8%80%E4%B8%AA%E7%AB%8B%E6%96%B9%E4%BD%93/</guid><description>&lt;p>本篇文章要实现的效果是：一个旋转的立方体&lt;/p>
&lt;p>代码对应 &lt;a href="https://github.com/SourceKim/OpenGLES-iOS">仓库&lt;/a> 中的 &lt;code>6. 旋转的立方体&lt;/code>&lt;/p></description></item><item><title>OpenGL ES in iOS - 6 三维变换</title><link>https://www.uiimage.com/post/blog/opengl-es/opengl-es-6-%E4%B8%89%E7%BB%B4%E5%8F%98%E6%8D%A2/</link><pubDate>Thu, 14 May 2020 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/opengl-es/opengl-es-6-%E4%B8%89%E7%BB%B4%E5%8F%98%E6%8D%A2/</guid><description>&lt;p>本章将介绍 OpenGL ES 三维变换相关，主要是 MVP 矩阵（Model / View / Projection），最终通过不过地让摄像头围绕 2D 图片移动，实现图片旋转。&lt;/p>
&lt;p>本章的代码对应 &lt;a href="https://github.com/SourceKim/OpenGLES-iOS">仓库&lt;/a> 中的 &lt;code>5.三维变换&lt;/code>&lt;/p></description></item><item><title>OpenGL ES in iOS - 5 绘制到 texture (实现滤镜链)</title><link>https://www.uiimage.com/post/blog/opengl-es/opengl-es-5-%E7%BB%98%E5%88%B6%E5%88%B0-texture-%E5%AE%9E%E7%8E%B0%E6%BB%A4%E9%95%9C%E9%93%BE/</link><pubDate>Tue, 12 May 2020 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/opengl-es/opengl-es-5-%E7%BB%98%E5%88%B6%E5%88%B0-texture-%E5%AE%9E%E7%8E%B0%E6%BB%A4%E9%95%9C%E9%93%BE/</guid><description>&lt;p>OpenGL 的纹理对象（&lt;code>FBO&lt;/code>）的 attachment 除了可以与渲染对象（&lt;code>RBO&lt;/code>）绑定直接输出之外，还可以与一个 &lt;code>2DTexture&lt;/code> 绑定，这样就可以使用该特性，来对 &lt;code>Texture&lt;/code> 进行多次修改（滤镜链），最后才将其渲染到 &lt;code>RBO&lt;/code> 来展示结果。&lt;/p>
&lt;p>本章的代码对应 &lt;a href="https://github.com/SourceKim/OpenGLES-iOS">仓库&lt;/a> 中的 &lt;code>4.滤镜链&lt;/code>&lt;/p></description></item><item><title>OpenGL ES in iOS - 4. 纹理采样详解</title><link>https://www.uiimage.com/post/blog/opengl-es/opengl-es-4-%E7%BA%B9%E7%90%86%E9%87%87%E6%A0%B7%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 11 May 2020 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/opengl-es/opengl-es-4-%E7%BA%B9%E7%90%86%E9%87%87%E6%A0%B7%E8%AF%A6%E8%A7%A3/</guid><description>&lt;p>包括如下内容：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一、绘图填充模式&lt;/p>
&lt;p>类似 iOS 的 UIImageView 的填充模式：&lt;/p>
&lt;ul>
&lt;li>
&lt;ol>
&lt;li>&lt;code>ScaleToFill&lt;/code> 缩放填充，不保持比例&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;ol start="2">
&lt;li>&lt;code>ScaleAspectFit&lt;/code> 缩放到所有内容完整居中显示，保持比例，多余的地方留白&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;ol start="3">
&lt;li>&lt;code>ScaleAspectFill&lt;/code> 缩放居中填满整个画面，保持比例，超出的地方裁剪&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>二、纹理采样参数&lt;/p>
&lt;p>当读取的纹理坐标超出纹理的时候如何处理&lt;/p>
&lt;p>主要是 &lt;code>glTexParameteri&lt;/code> 的 4 种 采样 mode：&lt;/p>
&lt;ul>
&lt;li>&lt;code>GL_CLAMP_TO_EDGE&lt;/code>&lt;/li>
&lt;li>&lt;del>GL_CLAMP_TO_BORDER&lt;/del> iOS 不支持这种&lt;/li>
&lt;li>&lt;code>GL_REPEAT&lt;/code>&lt;/li>
&lt;li>&lt;code>GL_MIRRORED_REPEAT&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>以及 &lt;code>glTexParameteri&lt;/code> 的插值模式&lt;/p>
&lt;ul>
&lt;li>&lt;code>GL_NEAREST&lt;/code>&lt;/li>
&lt;li>&lt;code>GL_LINEAR&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>OpenGL ES in iOS - 3. 画一张图片</title><link>https://www.uiimage.com/post/blog/opengl-es/opengl-es-3-%E7%94%BB%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87/</link><pubDate>Sun, 10 May 2020 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/opengl-es/opengl-es-3-%E7%94%BB%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87/</guid><description>&lt;p>本篇的最终目的是通过 OpenGL ES 的 &lt;code>glTexImage2D&lt;/code> API，将一张 2D 的 JPG 图片，转换成纹理，然后画到 layer 上。&lt;/p></description></item><item><title>[UIScreen mainScreen].bounds 总是 320 480</title><link>https://www.uiimage.com/post/blog/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/uiscreen-mainscreen.bounds-%E6%80%BB%E6%98%AF-320-480/</link><pubDate>Wed, 06 May 2020 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/uiscreen-mainscreen.bounds-%E6%80%BB%E6%98%AF-320-480/</guid><description>&lt;p>今天遇到一个问题：打印 &lt;code>[UIScreen mainScreen].bound&lt;/code> 的时候总是得到 320 X 480。&lt;/p></description></item><item><title>SDWebImage 笔记</title><link>https://www.uiimage.com/post/blog/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/sdwebimage/</link><pubDate>Thu, 21 Nov 2019 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/sdwebimage/</guid><description>&lt;p>SDWebImage 是 iOS 常用的图片加载框架，支持对网络图片进行 内存 &amp;amp; 硬盘 缓存，并且能很方便地将图片应用到 UIImageView、UIButton 等控件上&lt;/p></description></item><item><title>AVFoundation - 1. 基础介绍</title><link>https://www.uiimage.com/post/blog/%E9%9F%B3%E8%A7%86%E9%A2%91/avfoundation/</link><pubDate>Thu, 14 Nov 2019 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/%E9%9F%B3%E8%A7%86%E9%A2%91/avfoundation/</guid><description>&lt;p>AVFoundation 基础介绍，包括 &lt;code>CMTime&lt;/code> 的介绍和常用的一些类介绍&lt;/p></description></item><item><title>编译 &amp; 加载 原理</title><link>https://www.uiimage.com/post/blog/ios/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</link><pubDate>Sat, 26 Oct 2019 14:20:35 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/ios/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</guid><description>&lt;p>我们所写的代码是一个 &lt;code>XCode&lt;/code> 的工程，在按下 &lt;code>command + r&lt;/code> 之时，会将其 &lt;code>编译&lt;/code> 成 &lt;code>MACH-O&lt;/code> 可执行文件；然后放到手机上，再点击应用的时候，系统的内核会开启一个进程，然后通过 &lt;code>dyld&lt;/code> 执行 &lt;code>加载&lt;/code> 流程。&lt;/p></description></item><item><title>iOS 中 weak 详细介绍</title><link>https://www.uiimage.com/post/blog/ios/weak/</link><pubDate>Wed, 08 May 2019 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/ios/weak/</guid><description>&lt;p>&lt;code>Runtime&lt;/code> 为我们维护了一张&lt;strong>全局&lt;/strong>的 &lt;code>weak 表（弱引用表）&lt;/code>，是一张 &lt;code>哈希表&lt;/code>，该表的 &lt;code>key&lt;/code> 是要弱引用的对象的地址， &lt;code>value&lt;/code> 是所有指向该对象的 &lt;code>weak&lt;/code> 指针，是一个数组。&lt;/p></description></item><item><title>OpenGL ES in iOS - 2. 画一个三角形</title><link>https://www.uiimage.com/post/blog/opengl-es/opengl-es-2-%E7%94%BB%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/</link><pubDate>Mon, 29 Apr 2019 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/opengl-es/opengl-es-2-%E7%94%BB%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/</guid><description>&lt;p>本篇主要目的是 &lt;strong>使用 OpenGL ES 画一个三角形&lt;/strong>，包含 直接上传顶点、使用 VAO、VBO、EBO 他们的组合渲染方式。&lt;/p>
&lt;p>建议配合 &lt;a href="https://github.com/SourceKim/OpenGLES-iOS">Demo 工程&lt;/a> 食用。&lt;/p></description></item><item><title>OpenGL ES in iOS - 1. 基础概念</title><link>https://www.uiimage.com/post/blog/opengl-es/opengl-es-1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</link><pubDate>Thu, 18 Apr 2019 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/opengl-es/opengl-es-1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</guid><description>&lt;p>OpenGL ES 全称 OpenGL for Embedded Systems，是专门为嵌入式设备改良的 开源图形库&lt;/p>
&lt;p>OpenGL ES 是 OpenGL 的简化版本，简化了一些功能。&lt;/p>
&lt;p>OpenGL ES 的实现是基于 C 的&lt;/p></description></item><item><title>Hash isEqual == 的区别和联系</title><link>https://www.uiimage.com/post/blog/ios/hashisequal/</link><pubDate>Fri, 12 Apr 2019 13:12:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/ios/hashisequal/</guid><description>&lt;p>在 OC 中：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>hash&lt;/code> 的类型是 &lt;code>NSUInteger&lt;/code>，可以初步用来判等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>isEqual&lt;/code> 是相等的绝对判定&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>==&lt;/code> 仅是对比变量地址的指针是否相等&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>iOS 中 Runtime 详细介绍</title><link>https://www.uiimage.com/post/blog/ios/runtime/</link><pubDate>Mon, 04 Mar 2019 22:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/ios/runtime/</guid><description>&lt;p>Runtime，运行时的库，是一套使用 C 和汇编的 API，因为 runtime 使得 OC 可以成为一个动态语言。平时我们定义的对象，大多都是编译后就是 runtime 的 &lt;code>objc_class&lt;/code> 结构体；我们调用方法，编译之后会变成 &lt;code>objc_msgSend:&lt;/code>，也就是通过给对象发送消息来调用方法，方法实际的实现在运行时才能被确定。&lt;/p></description></item><item><title>Block 原理 &amp; 本质</title><link>https://www.uiimage.com/post/blog/ios/block/</link><pubDate>Thu, 17 Jan 2019 18:20:35 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/ios/block/</guid><description>&lt;p>iOS 的 &lt;code>block&lt;/code> 本质上也是一个 OC 的对象，是一个拥有 &lt;code>isa&lt;/code> 指针的结构体，能够捕获外部变量的值、指针地址。&lt;/p></description></item><item><title>iOS 中 Runloop 详细介绍</title><link>https://www.uiimage.com/post/blog/ios/runloop/</link><pubDate>Fri, 04 Jan 2019 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/ios/runloop/</guid><description>&lt;p>为了维持程序中任务的持续进行，iOS 中采用 Runloop 这种方式。&lt;/p></description></item><item><title>iOS 中的 YUV 格式</title><link>https://www.uiimage.com/post/blog/%E9%9F%B3%E8%A7%86%E9%A2%91/yuv/</link><pubDate>Wed, 20 Jun 2018 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/%E9%9F%B3%E8%A7%86%E9%A2%91/yuv/</guid><description>&lt;p>YUV 和 RGB 相比：Y 表示亮度，UV 分量表示色差，能更好地对颜色进行 &lt;strong>压缩&lt;/strong>。&lt;/p>
&lt;p>在 iOS 中的 YUV 主要有两大类：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>NV12：（双平面 BiPlanar）&lt;/p>
&lt;ul>
&lt;li>
&lt;p>kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange 即 420v&lt;/p>
&lt;/li>
&lt;li>
&lt;p>kCVPixelFormatType_420YpCbCr8BiPlanarFullRange 即 420f&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>YUV420P：（单平面 Planar）&lt;/p>
&lt;ul>
&lt;li>kCVPixelFormatType_420YpCbCr8Planar 即 y420&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>iOS 杂记</title><link>https://www.uiimage.com/post/blog/ios/ios/</link><pubDate>Wed, 02 May 2018 03:32:24 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/ios/ios/</guid><description>&lt;p>记录 iOS 常用知识点&lt;/p></description></item><item><title>iOS 中锁的探究</title><link>https://www.uiimage.com/post/blog/ios/lock/</link><pubDate>Thu, 03 Aug 2017 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/ios/lock/</guid><description>&lt;p>iOS 中的锁分为：互斥锁、递归锁、条件锁、自旋锁等。&lt;/p></description></item><item><title>iOS 的 架构 &amp; 寄存器（register）</title><link>https://www.uiimage.com/post/blog/ios/register/</link><pubDate>Thu, 03 Aug 2017 23:00:00 +0800</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/ios/register/</guid><description>&lt;p>包括所有架构的介绍和部分寄存器的作用。&lt;/p></description></item><item><title>iOS 的 KVO &amp; KVC 本质</title><link>https://www.uiimage.com/post/blog/ios/kvokvc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>18666269733@163.com (Kim)</author><guid>https://www.uiimage.com/post/blog/ios/kvokvc/</guid><description>&lt;ul>
&lt;li>
&lt;p>KVO：监听属性的变化&lt;/p>
&lt;/li>
&lt;li>
&lt;p>KVC：属性（成员变量）设值&lt;/p>
&lt;/li>
&lt;/ul></description></item></channel></rss>